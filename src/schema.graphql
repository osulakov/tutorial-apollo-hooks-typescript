schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# columns and relationships of "account_channels"
type account_channels {
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!
  description: String
  value: String!
}

# aggregated selection of "account_channels"
type account_channels_aggregate {
  aggregate: account_channels_aggregate_fields
  nodes: [account_channels!]!
}

# aggregate fields of "account_channels"
type account_channels_aggregate_fields {
  count(columns: [account_channels_select_column!], distinct: Boolean): Int
  max: account_channels_max_fields
  min: account_channels_min_fields
}

# order by aggregate values of table "account_channels"
input account_channels_aggregate_order_by {
  count: order_by
  max: account_channels_max_order_by
  min: account_channels_min_order_by
}

# input type for inserting array relation for remote table "account_channels"
input account_channels_arr_rel_insert_input {
  data: [account_channels_insert_input!]!
  on_conflict: account_channels_on_conflict
}

# Boolean expression to filter rows from the table "account_channels". All fields are combined with a logical 'AND'.
input account_channels_bool_exp {
  _and: [account_channels_bool_exp]
  _not: account_channels_bool_exp
  _or: [account_channels_bool_exp]
  accounts: accounts_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "account_channels"
enum account_channels_constraint {
  # unique or primary key constraint
  account_channels_pkey
}

# input type for inserting data into table "account_channels"
input account_channels_insert_input {
  accounts: accounts_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type account_channels_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "account_channels"
input account_channels_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type account_channels_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "account_channels"
input account_channels_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "account_channels"
type account_channels_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_channels!]!
}

# input type for inserting object relation for remote table "account_channels"
input account_channels_obj_rel_insert_input {
  data: account_channels_insert_input!
  on_conflict: account_channels_on_conflict
}

# on conflict condition type for table "account_channels"
input account_channels_on_conflict {
  constraint: account_channels_constraint!
  update_columns: [account_channels_update_column!]!
  where: account_channels_bool_exp
}

# ordering options when selecting data from "account_channels"
input account_channels_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "account_channels"
input account_channels_pk_columns_input {
  value: String!
}

# select columns of table "account_channels"
enum account_channels_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "account_channels"
input account_channels_set_input {
  description: String
  value: String
}

# update columns of table "account_channels"
enum account_channels_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "account_payment_terms"
type account_payment_terms {
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!
  description: String
  value: String!
}

# aggregated selection of "account_payment_terms"
type account_payment_terms_aggregate {
  aggregate: account_payment_terms_aggregate_fields
  nodes: [account_payment_terms!]!
}

# aggregate fields of "account_payment_terms"
type account_payment_terms_aggregate_fields {
  count(columns: [account_payment_terms_select_column!], distinct: Boolean): Int
  max: account_payment_terms_max_fields
  min: account_payment_terms_min_fields
}

# order by aggregate values of table "account_payment_terms"
input account_payment_terms_aggregate_order_by {
  count: order_by
  max: account_payment_terms_max_order_by
  min: account_payment_terms_min_order_by
}

# input type for inserting array relation for remote table "account_payment_terms"
input account_payment_terms_arr_rel_insert_input {
  data: [account_payment_terms_insert_input!]!
  on_conflict: account_payment_terms_on_conflict
}

# Boolean expression to filter rows from the table "account_payment_terms". All fields are combined with a logical 'AND'.
input account_payment_terms_bool_exp {
  _and: [account_payment_terms_bool_exp]
  _not: account_payment_terms_bool_exp
  _or: [account_payment_terms_bool_exp]
  accounts: accounts_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "account_payment_terms"
enum account_payment_terms_constraint {
  # unique or primary key constraint
  account_payment_terms_pkey
}

# input type for inserting data into table "account_payment_terms"
input account_payment_terms_insert_input {
  accounts: accounts_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type account_payment_terms_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "account_payment_terms"
input account_payment_terms_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type account_payment_terms_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "account_payment_terms"
input account_payment_terms_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "account_payment_terms"
type account_payment_terms_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_payment_terms!]!
}

# input type for inserting object relation for remote table "account_payment_terms"
input account_payment_terms_obj_rel_insert_input {
  data: account_payment_terms_insert_input!
  on_conflict: account_payment_terms_on_conflict
}

# on conflict condition type for table "account_payment_terms"
input account_payment_terms_on_conflict {
  constraint: account_payment_terms_constraint!
  update_columns: [account_payment_terms_update_column!]!
  where: account_payment_terms_bool_exp
}

# ordering options when selecting data from "account_payment_terms"
input account_payment_terms_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "account_payment_terms"
input account_payment_terms_pk_columns_input {
  value: String!
}

# select columns of table "account_payment_terms"
enum account_payment_terms_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "account_payment_terms"
input account_payment_terms_set_input {
  description: String
  value: String
}

# update columns of table "account_payment_terms"
enum account_payment_terms_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "account_regions"
type account_regions {
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!
  description: String
  value: String!
}

# aggregated selection of "account_regions"
type account_regions_aggregate {
  aggregate: account_regions_aggregate_fields
  nodes: [account_regions!]!
}

# aggregate fields of "account_regions"
type account_regions_aggregate_fields {
  count(columns: [account_regions_select_column!], distinct: Boolean): Int
  max: account_regions_max_fields
  min: account_regions_min_fields
}

# order by aggregate values of table "account_regions"
input account_regions_aggregate_order_by {
  count: order_by
  max: account_regions_max_order_by
  min: account_regions_min_order_by
}

# input type for inserting array relation for remote table "account_regions"
input account_regions_arr_rel_insert_input {
  data: [account_regions_insert_input!]!
  on_conflict: account_regions_on_conflict
}

# Boolean expression to filter rows from the table "account_regions". All fields are combined with a logical 'AND'.
input account_regions_bool_exp {
  _and: [account_regions_bool_exp]
  _not: account_regions_bool_exp
  _or: [account_regions_bool_exp]
  accounts: accounts_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "account_regions"
enum account_regions_constraint {
  # unique or primary key constraint
  account_regions_pkey
}

# input type for inserting data into table "account_regions"
input account_regions_insert_input {
  accounts: accounts_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type account_regions_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "account_regions"
input account_regions_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type account_regions_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "account_regions"
input account_regions_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "account_regions"
type account_regions_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_regions!]!
}

# input type for inserting object relation for remote table "account_regions"
input account_regions_obj_rel_insert_input {
  data: account_regions_insert_input!
  on_conflict: account_regions_on_conflict
}

# on conflict condition type for table "account_regions"
input account_regions_on_conflict {
  constraint: account_regions_constraint!
  update_columns: [account_regions_update_column!]!
  where: account_regions_bool_exp
}

# ordering options when selecting data from "account_regions"
input account_regions_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "account_regions"
input account_regions_pk_columns_input {
  value: String!
}

# select columns of table "account_regions"
enum account_regions_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "account_regions"
input account_regions_set_input {
  description: String
  value: String
}

# update columns of table "account_regions"
enum account_regions_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "account_statuses"
type account_statuses {
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!
  description: String
  value: String!
}

# aggregated selection of "account_statuses"
type account_statuses_aggregate {
  aggregate: account_statuses_aggregate_fields
  nodes: [account_statuses!]!
}

# aggregate fields of "account_statuses"
type account_statuses_aggregate_fields {
  count(columns: [account_statuses_select_column!], distinct: Boolean): Int
  max: account_statuses_max_fields
  min: account_statuses_min_fields
}

# order by aggregate values of table "account_statuses"
input account_statuses_aggregate_order_by {
  count: order_by
  max: account_statuses_max_order_by
  min: account_statuses_min_order_by
}

# input type for inserting array relation for remote table "account_statuses"
input account_statuses_arr_rel_insert_input {
  data: [account_statuses_insert_input!]!
  on_conflict: account_statuses_on_conflict
}

# Boolean expression to filter rows from the table "account_statuses". All fields are combined with a logical 'AND'.
input account_statuses_bool_exp {
  _and: [account_statuses_bool_exp]
  _not: account_statuses_bool_exp
  _or: [account_statuses_bool_exp]
  accounts: accounts_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "account_statuses"
enum account_statuses_constraint {
  # unique or primary key constraint
  account_statuses_pkey
}

# input type for inserting data into table "account_statuses"
input account_statuses_insert_input {
  accounts: accounts_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type account_statuses_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "account_statuses"
input account_statuses_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type account_statuses_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "account_statuses"
input account_statuses_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "account_statuses"
type account_statuses_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_statuses!]!
}

# input type for inserting object relation for remote table "account_statuses"
input account_statuses_obj_rel_insert_input {
  data: account_statuses_insert_input!
  on_conflict: account_statuses_on_conflict
}

# on conflict condition type for table "account_statuses"
input account_statuses_on_conflict {
  constraint: account_statuses_constraint!
  update_columns: [account_statuses_update_column!]!
  where: account_statuses_bool_exp
}

# ordering options when selecting data from "account_statuses"
input account_statuses_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "account_statuses"
input account_statuses_pk_columns_input {
  value: String!
}

# select columns of table "account_statuses"
enum account_statuses_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "account_statuses"
input account_statuses_set_input {
  description: String
  value: String
}

# update columns of table "account_statuses"
enum account_statuses_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "account_tiers"
type account_tiers {
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!
  description: String
  value: String!
}

# aggregated selection of "account_tiers"
type account_tiers_aggregate {
  aggregate: account_tiers_aggregate_fields
  nodes: [account_tiers!]!
}

# aggregate fields of "account_tiers"
type account_tiers_aggregate_fields {
  count(columns: [account_tiers_select_column!], distinct: Boolean): Int
  max: account_tiers_max_fields
  min: account_tiers_min_fields
}

# order by aggregate values of table "account_tiers"
input account_tiers_aggregate_order_by {
  count: order_by
  max: account_tiers_max_order_by
  min: account_tiers_min_order_by
}

# input type for inserting array relation for remote table "account_tiers"
input account_tiers_arr_rel_insert_input {
  data: [account_tiers_insert_input!]!
  on_conflict: account_tiers_on_conflict
}

# Boolean expression to filter rows from the table "account_tiers". All fields are combined with a logical 'AND'.
input account_tiers_bool_exp {
  _and: [account_tiers_bool_exp]
  _not: account_tiers_bool_exp
  _or: [account_tiers_bool_exp]
  accounts: accounts_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "account_tiers"
enum account_tiers_constraint {
  # unique or primary key constraint
  account_tiers_pkey
}

# input type for inserting data into table "account_tiers"
input account_tiers_insert_input {
  accounts: accounts_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type account_tiers_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "account_tiers"
input account_tiers_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type account_tiers_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "account_tiers"
input account_tiers_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "account_tiers"
type account_tiers_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_tiers!]!
}

# input type for inserting object relation for remote table "account_tiers"
input account_tiers_obj_rel_insert_input {
  data: account_tiers_insert_input!
  on_conflict: account_tiers_on_conflict
}

# on conflict condition type for table "account_tiers"
input account_tiers_on_conflict {
  constraint: account_tiers_constraint!
  update_columns: [account_tiers_update_column!]!
  where: account_tiers_bool_exp
}

# ordering options when selecting data from "account_tiers"
input account_tiers_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "account_tiers"
input account_tiers_pk_columns_input {
  value: String!
}

# select columns of table "account_tiers"
enum account_tiers_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "account_tiers"
input account_tiers_set_input {
  description: String
  value: String
}

# update columns of table "account_tiers"
enum account_tiers_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "account_types"
type account_types {
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!
  description: String
  value: String!
}

# aggregated selection of "account_types"
type account_types_aggregate {
  aggregate: account_types_aggregate_fields
  nodes: [account_types!]!
}

# aggregate fields of "account_types"
type account_types_aggregate_fields {
  count(columns: [account_types_select_column!], distinct: Boolean): Int
  max: account_types_max_fields
  min: account_types_min_fields
}

# order by aggregate values of table "account_types"
input account_types_aggregate_order_by {
  count: order_by
  max: account_types_max_order_by
  min: account_types_min_order_by
}

# input type for inserting array relation for remote table "account_types"
input account_types_arr_rel_insert_input {
  data: [account_types_insert_input!]!
  on_conflict: account_types_on_conflict
}

# Boolean expression to filter rows from the table "account_types". All fields are combined with a logical 'AND'.
input account_types_bool_exp {
  _and: [account_types_bool_exp]
  _not: account_types_bool_exp
  _or: [account_types_bool_exp]
  accounts: accounts_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "account_types"
enum account_types_constraint {
  # unique or primary key constraint
  account_types_pkey
}

# input type for inserting data into table "account_types"
input account_types_insert_input {
  accounts: accounts_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type account_types_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "account_types"
input account_types_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type account_types_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "account_types"
input account_types_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "account_types"
type account_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_types!]!
}

# input type for inserting object relation for remote table "account_types"
input account_types_obj_rel_insert_input {
  data: account_types_insert_input!
  on_conflict: account_types_on_conflict
}

# on conflict condition type for table "account_types"
input account_types_on_conflict {
  constraint: account_types_constraint!
  update_columns: [account_types_update_column!]!
  where: account_types_bool_exp
}

# ordering options when selecting data from "account_types"
input account_types_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "account_types"
input account_types_pk_columns_input {
  value: String!
}

# select columns of table "account_types"
enum account_types_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "account_types"
input account_types_set_input {
  description: String
  value: String
}

# update columns of table "account_types"
enum account_types_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "account_verticals"
type account_verticals {
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!
  description: String
  value: String!
}

# aggregated selection of "account_verticals"
type account_verticals_aggregate {
  aggregate: account_verticals_aggregate_fields
  nodes: [account_verticals!]!
}

# aggregate fields of "account_verticals"
type account_verticals_aggregate_fields {
  count(columns: [account_verticals_select_column!], distinct: Boolean): Int
  max: account_verticals_max_fields
  min: account_verticals_min_fields
}

# order by aggregate values of table "account_verticals"
input account_verticals_aggregate_order_by {
  count: order_by
  max: account_verticals_max_order_by
  min: account_verticals_min_order_by
}

# input type for inserting array relation for remote table "account_verticals"
input account_verticals_arr_rel_insert_input {
  data: [account_verticals_insert_input!]!
  on_conflict: account_verticals_on_conflict
}

# Boolean expression to filter rows from the table "account_verticals". All fields are combined with a logical 'AND'.
input account_verticals_bool_exp {
  _and: [account_verticals_bool_exp]
  _not: account_verticals_bool_exp
  _or: [account_verticals_bool_exp]
  accounts: accounts_bool_exp
  description: String_comparison_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "account_verticals"
enum account_verticals_constraint {
  # unique or primary key constraint
  account_verticals_pkey
}

# input type for inserting data into table "account_verticals"
input account_verticals_insert_input {
  accounts: accounts_arr_rel_insert_input
  description: String
  value: String
}

# aggregate max on columns
type account_verticals_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "account_verticals"
input account_verticals_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type account_verticals_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "account_verticals"
input account_verticals_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "account_verticals"
type account_verticals_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account_verticals!]!
}

# input type for inserting object relation for remote table "account_verticals"
input account_verticals_obj_rel_insert_input {
  data: account_verticals_insert_input!
  on_conflict: account_verticals_on_conflict
}

# on conflict condition type for table "account_verticals"
input account_verticals_on_conflict {
  constraint: account_verticals_constraint!
  update_columns: [account_verticals_update_column!]!
  where: account_verticals_bool_exp
}

# ordering options when selecting data from "account_verticals"
input account_verticals_order_by {
  accounts_aggregate: accounts_aggregate_order_by
  description: order_by
  value: order_by
}

# primary key columns input for table: "account_verticals"
input account_verticals_pk_columns_input {
  value: String!
}

# select columns of table "account_verticals"
enum account_verticals_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "account_verticals"
input account_verticals_set_input {
  description: String
  value: String
}

# update columns of table "account_verticals"
enum account_verticals_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "accounts"
type accounts {
  # An object relationship
  account_channel: account_channels!
  account_manager: String

  # An object relationship
  account_payment_term: account_payment_terms!

  # An object relationship
  account_region: account_regions!

  # An object relationship
  account_status: account_statuses!

  # An object relationship
  account_tier: account_tiers!

  # An object relationship
  account_type: account_types!

  # An object relationship
  account_vertical: account_verticals!
  advertiser_blocks: String
  bill_to: String
  billing_city: String
  billing_contact_city: String
  billing_contact_country: String
  billing_contact_email: String
  billing_contact_name: String
  billing_contact_phone_number: String
  billing_contact_postal_code: String
  billing_contact_region_state: String
  billing_contact_street: String
  billing_contact_title: String
  billing_country: String
  billing_postal_code: String
  billing_region_state: String
  billing_street: String
  channel: String!
  channel_blocks: String
  child_pixel_id: Int
  click_attribution_window: smallint
  click_lift_percentage: numeric
  connection_method: String

  # An array relationship
  contracts(
    # distinct select on columns
    distinct_on: [contracts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contracts_order_by!]

    # filter the rows returned
    where: contracts_bool_exp
  ): [contracts!]!

  # An aggregated array relationship
  contracts_aggregate(
    # distinct select on columns
    distinct_on: [contracts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contracts_order_by!]

    # filter the rows returned
    where: contracts_bool_exp
  ): contracts_aggregate!
  created_at: timestamptz!
  credit_limit: String
  currency: String
  destination_country: String
  destination_postal_code: String
  external_id: Int
  id: Int!
  integration_contact_email: String
  integration_contact_name: String
  integration_contact_phone_number: String
  integration_contact_title: String
  inventory_whitelist_blacklist: String
  market_area_cities: String
  market_area_countries: String
  name: String!
  parent_account_id: Int
  parent_pixel_id: Int
  payment_method: String
  payment_terms: String!
  region: String!
  sales_rep: String
  sfdc_account_id: Int
  status: String!
  tags: String
  tier: String!
  time_zone: String
  type: String!
  updated_at: timestamptz!
  vertical: String!
  vertical_blocks: String
  view_attribution_window: smallint
  view_lift_percentage: numeric
}

# aggregated selection of "accounts"
type accounts_aggregate {
  aggregate: accounts_aggregate_fields
  nodes: [accounts!]!
}

# aggregate fields of "accounts"
type accounts_aggregate_fields {
  avg: accounts_avg_fields
  count(columns: [accounts_select_column!], distinct: Boolean): Int
  max: accounts_max_fields
  min: accounts_min_fields
  stddev: accounts_stddev_fields
  stddev_pop: accounts_stddev_pop_fields
  stddev_samp: accounts_stddev_samp_fields
  sum: accounts_sum_fields
  var_pop: accounts_var_pop_fields
  var_samp: accounts_var_samp_fields
  variance: accounts_variance_fields
}

# order by aggregate values of table "accounts"
input accounts_aggregate_order_by {
  avg: accounts_avg_order_by
  count: order_by
  max: accounts_max_order_by
  min: accounts_min_order_by
  stddev: accounts_stddev_order_by
  stddev_pop: accounts_stddev_pop_order_by
  stddev_samp: accounts_stddev_samp_order_by
  sum: accounts_sum_order_by
  var_pop: accounts_var_pop_order_by
  var_samp: accounts_var_samp_order_by
  variance: accounts_variance_order_by
}

# input type for inserting array relation for remote table "accounts"
input accounts_arr_rel_insert_input {
  data: [accounts_insert_input!]!
  on_conflict: accounts_on_conflict
}

# aggregate avg on columns
type accounts_avg_fields {
  child_pixel_id: Float
  click_attribution_window: Float
  click_lift_percentage: Float
  external_id: Float
  id: Float
  parent_account_id: Float
  parent_pixel_id: Float
  sfdc_account_id: Float
  view_attribution_window: Float
  view_lift_percentage: Float
}

# order by avg() on columns of table "accounts"
input accounts_avg_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# Boolean expression to filter rows from the table "accounts". All fields are combined with a logical 'AND'.
input accounts_bool_exp {
  _and: [accounts_bool_exp]
  _not: accounts_bool_exp
  _or: [accounts_bool_exp]
  account_channel: account_channels_bool_exp
  account_manager: String_comparison_exp
  account_payment_term: account_payment_terms_bool_exp
  account_region: account_regions_bool_exp
  account_status: account_statuses_bool_exp
  account_tier: account_tiers_bool_exp
  account_type: account_types_bool_exp
  account_vertical: account_verticals_bool_exp
  advertiser_blocks: String_comparison_exp
  bill_to: String_comparison_exp
  billing_city: String_comparison_exp
  billing_contact_city: String_comparison_exp
  billing_contact_country: String_comparison_exp
  billing_contact_email: String_comparison_exp
  billing_contact_name: String_comparison_exp
  billing_contact_phone_number: String_comparison_exp
  billing_contact_postal_code: String_comparison_exp
  billing_contact_region_state: String_comparison_exp
  billing_contact_street: String_comparison_exp
  billing_contact_title: String_comparison_exp
  billing_country: String_comparison_exp
  billing_postal_code: String_comparison_exp
  billing_region_state: String_comparison_exp
  billing_street: String_comparison_exp
  channel: String_comparison_exp
  channel_blocks: String_comparison_exp
  child_pixel_id: Int_comparison_exp
  click_attribution_window: smallint_comparison_exp
  click_lift_percentage: numeric_comparison_exp
  connection_method: String_comparison_exp
  contracts: contracts_bool_exp
  created_at: timestamptz_comparison_exp
  credit_limit: String_comparison_exp
  currency: String_comparison_exp
  destination_country: String_comparison_exp
  destination_postal_code: String_comparison_exp
  external_id: Int_comparison_exp
  id: Int_comparison_exp
  integration_contact_email: String_comparison_exp
  integration_contact_name: String_comparison_exp
  integration_contact_phone_number: String_comparison_exp
  integration_contact_title: String_comparison_exp
  inventory_whitelist_blacklist: String_comparison_exp
  market_area_cities: String_comparison_exp
  market_area_countries: String_comparison_exp
  name: String_comparison_exp
  parent_account_id: Int_comparison_exp
  parent_pixel_id: Int_comparison_exp
  payment_method: String_comparison_exp
  payment_terms: String_comparison_exp
  region: String_comparison_exp
  sales_rep: String_comparison_exp
  sfdc_account_id: Int_comparison_exp
  status: String_comparison_exp
  tags: String_comparison_exp
  tier: String_comparison_exp
  time_zone: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  vertical: String_comparison_exp
  vertical_blocks: String_comparison_exp
  view_attribution_window: smallint_comparison_exp
  view_lift_percentage: numeric_comparison_exp
}

# unique or primary key constraints on table "accounts"
enum accounts_constraint {
  # unique or primary key constraint
  accounts_pkey
}

# input type for incrementing integer column in table "accounts"
input accounts_inc_input {
  child_pixel_id: Int
  click_attribution_window: smallint
  click_lift_percentage: numeric
  external_id: Int
  id: Int
  parent_account_id: Int
  parent_pixel_id: Int
  sfdc_account_id: Int
  view_attribution_window: smallint
  view_lift_percentage: numeric
}

# input type for inserting data into table "accounts"
input accounts_insert_input {
  account_channel: account_channels_obj_rel_insert_input
  account_manager: String
  account_payment_term: account_payment_terms_obj_rel_insert_input
  account_region: account_regions_obj_rel_insert_input
  account_status: account_statuses_obj_rel_insert_input
  account_tier: account_tiers_obj_rel_insert_input
  account_type: account_types_obj_rel_insert_input
  account_vertical: account_verticals_obj_rel_insert_input
  advertiser_blocks: String
  bill_to: String
  billing_city: String
  billing_contact_city: String
  billing_contact_country: String
  billing_contact_email: String
  billing_contact_name: String
  billing_contact_phone_number: String
  billing_contact_postal_code: String
  billing_contact_region_state: String
  billing_contact_street: String
  billing_contact_title: String
  billing_country: String
  billing_postal_code: String
  billing_region_state: String
  billing_street: String
  channel: String
  channel_blocks: String
  child_pixel_id: Int
  click_attribution_window: smallint
  click_lift_percentage: numeric
  connection_method: String
  contracts: contracts_arr_rel_insert_input
  created_at: timestamptz
  credit_limit: String
  currency: String
  destination_country: String
  destination_postal_code: String
  external_id: Int
  id: Int
  integration_contact_email: String
  integration_contact_name: String
  integration_contact_phone_number: String
  integration_contact_title: String
  inventory_whitelist_blacklist: String
  market_area_cities: String
  market_area_countries: String
  name: String
  parent_account_id: Int
  parent_pixel_id: Int
  payment_method: String
  payment_terms: String
  region: String
  sales_rep: String
  sfdc_account_id: Int
  status: String
  tags: String
  tier: String
  time_zone: String
  type: String
  updated_at: timestamptz
  vertical: String
  vertical_blocks: String
  view_attribution_window: smallint
  view_lift_percentage: numeric
}

# aggregate max on columns
type accounts_max_fields {
  account_manager: String
  advertiser_blocks: String
  bill_to: String
  billing_city: String
  billing_contact_city: String
  billing_contact_country: String
  billing_contact_email: String
  billing_contact_name: String
  billing_contact_phone_number: String
  billing_contact_postal_code: String
  billing_contact_region_state: String
  billing_contact_street: String
  billing_contact_title: String
  billing_country: String
  billing_postal_code: String
  billing_region_state: String
  billing_street: String
  channel: String
  channel_blocks: String
  child_pixel_id: Int
  click_attribution_window: smallint
  click_lift_percentage: numeric
  connection_method: String
  created_at: timestamptz
  credit_limit: String
  currency: String
  destination_country: String
  destination_postal_code: String
  external_id: Int
  id: Int
  integration_contact_email: String
  integration_contact_name: String
  integration_contact_phone_number: String
  integration_contact_title: String
  inventory_whitelist_blacklist: String
  market_area_cities: String
  market_area_countries: String
  name: String
  parent_account_id: Int
  parent_pixel_id: Int
  payment_method: String
  payment_terms: String
  region: String
  sales_rep: String
  sfdc_account_id: Int
  status: String
  tags: String
  tier: String
  time_zone: String
  type: String
  updated_at: timestamptz
  vertical: String
  vertical_blocks: String
  view_attribution_window: smallint
  view_lift_percentage: numeric
}

# order by max() on columns of table "accounts"
input accounts_max_order_by {
  account_manager: order_by
  advertiser_blocks: order_by
  bill_to: order_by
  billing_city: order_by
  billing_contact_city: order_by
  billing_contact_country: order_by
  billing_contact_email: order_by
  billing_contact_name: order_by
  billing_contact_phone_number: order_by
  billing_contact_postal_code: order_by
  billing_contact_region_state: order_by
  billing_contact_street: order_by
  billing_contact_title: order_by
  billing_country: order_by
  billing_postal_code: order_by
  billing_region_state: order_by
  billing_street: order_by
  channel: order_by
  channel_blocks: order_by
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  connection_method: order_by
  created_at: order_by
  credit_limit: order_by
  currency: order_by
  destination_country: order_by
  destination_postal_code: order_by
  external_id: order_by
  id: order_by
  integration_contact_email: order_by
  integration_contact_name: order_by
  integration_contact_phone_number: order_by
  integration_contact_title: order_by
  inventory_whitelist_blacklist: order_by
  market_area_cities: order_by
  market_area_countries: order_by
  name: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  payment_method: order_by
  payment_terms: order_by
  region: order_by
  sales_rep: order_by
  sfdc_account_id: order_by
  status: order_by
  tags: order_by
  tier: order_by
  time_zone: order_by
  type: order_by
  updated_at: order_by
  vertical: order_by
  vertical_blocks: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# aggregate min on columns
type accounts_min_fields {
  account_manager: String
  advertiser_blocks: String
  bill_to: String
  billing_city: String
  billing_contact_city: String
  billing_contact_country: String
  billing_contact_email: String
  billing_contact_name: String
  billing_contact_phone_number: String
  billing_contact_postal_code: String
  billing_contact_region_state: String
  billing_contact_street: String
  billing_contact_title: String
  billing_country: String
  billing_postal_code: String
  billing_region_state: String
  billing_street: String
  channel: String
  channel_blocks: String
  child_pixel_id: Int
  click_attribution_window: smallint
  click_lift_percentage: numeric
  connection_method: String
  created_at: timestamptz
  credit_limit: String
  currency: String
  destination_country: String
  destination_postal_code: String
  external_id: Int
  id: Int
  integration_contact_email: String
  integration_contact_name: String
  integration_contact_phone_number: String
  integration_contact_title: String
  inventory_whitelist_blacklist: String
  market_area_cities: String
  market_area_countries: String
  name: String
  parent_account_id: Int
  parent_pixel_id: Int
  payment_method: String
  payment_terms: String
  region: String
  sales_rep: String
  sfdc_account_id: Int
  status: String
  tags: String
  tier: String
  time_zone: String
  type: String
  updated_at: timestamptz
  vertical: String
  vertical_blocks: String
  view_attribution_window: smallint
  view_lift_percentage: numeric
}

# order by min() on columns of table "accounts"
input accounts_min_order_by {
  account_manager: order_by
  advertiser_blocks: order_by
  bill_to: order_by
  billing_city: order_by
  billing_contact_city: order_by
  billing_contact_country: order_by
  billing_contact_email: order_by
  billing_contact_name: order_by
  billing_contact_phone_number: order_by
  billing_contact_postal_code: order_by
  billing_contact_region_state: order_by
  billing_contact_street: order_by
  billing_contact_title: order_by
  billing_country: order_by
  billing_postal_code: order_by
  billing_region_state: order_by
  billing_street: order_by
  channel: order_by
  channel_blocks: order_by
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  connection_method: order_by
  created_at: order_by
  credit_limit: order_by
  currency: order_by
  destination_country: order_by
  destination_postal_code: order_by
  external_id: order_by
  id: order_by
  integration_contact_email: order_by
  integration_contact_name: order_by
  integration_contact_phone_number: order_by
  integration_contact_title: order_by
  inventory_whitelist_blacklist: order_by
  market_area_cities: order_by
  market_area_countries: order_by
  name: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  payment_method: order_by
  payment_terms: order_by
  region: order_by
  sales_rep: order_by
  sfdc_account_id: order_by
  status: order_by
  tags: order_by
  tier: order_by
  time_zone: order_by
  type: order_by
  updated_at: order_by
  vertical: order_by
  vertical_blocks: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# response of any mutation on the table "accounts"
type accounts_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [accounts!]!
}

# input type for inserting object relation for remote table "accounts"
input accounts_obj_rel_insert_input {
  data: accounts_insert_input!
  on_conflict: accounts_on_conflict
}

# on conflict condition type for table "accounts"
input accounts_on_conflict {
  constraint: accounts_constraint!
  update_columns: [accounts_update_column!]!
  where: accounts_bool_exp
}

# ordering options when selecting data from "accounts"
input accounts_order_by {
  account_channel: account_channels_order_by
  account_manager: order_by
  account_payment_term: account_payment_terms_order_by
  account_region: account_regions_order_by
  account_status: account_statuses_order_by
  account_tier: account_tiers_order_by
  account_type: account_types_order_by
  account_vertical: account_verticals_order_by
  advertiser_blocks: order_by
  bill_to: order_by
  billing_city: order_by
  billing_contact_city: order_by
  billing_contact_country: order_by
  billing_contact_email: order_by
  billing_contact_name: order_by
  billing_contact_phone_number: order_by
  billing_contact_postal_code: order_by
  billing_contact_region_state: order_by
  billing_contact_street: order_by
  billing_contact_title: order_by
  billing_country: order_by
  billing_postal_code: order_by
  billing_region_state: order_by
  billing_street: order_by
  channel: order_by
  channel_blocks: order_by
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  connection_method: order_by
  contracts_aggregate: contracts_aggregate_order_by
  created_at: order_by
  credit_limit: order_by
  currency: order_by
  destination_country: order_by
  destination_postal_code: order_by
  external_id: order_by
  id: order_by
  integration_contact_email: order_by
  integration_contact_name: order_by
  integration_contact_phone_number: order_by
  integration_contact_title: order_by
  inventory_whitelist_blacklist: order_by
  market_area_cities: order_by
  market_area_countries: order_by
  name: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  payment_method: order_by
  payment_terms: order_by
  region: order_by
  sales_rep: order_by
  sfdc_account_id: order_by
  status: order_by
  tags: order_by
  tier: order_by
  time_zone: order_by
  type: order_by
  updated_at: order_by
  vertical: order_by
  vertical_blocks: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# primary key columns input for table: "accounts"
input accounts_pk_columns_input {
  id: Int!
}

# select columns of table "accounts"
enum accounts_select_column {
  # column name
  account_manager

  # column name
  advertiser_blocks

  # column name
  bill_to

  # column name
  billing_city

  # column name
  billing_contact_city

  # column name
  billing_contact_country

  # column name
  billing_contact_email

  # column name
  billing_contact_name

  # column name
  billing_contact_phone_number

  # column name
  billing_contact_postal_code

  # column name
  billing_contact_region_state

  # column name
  billing_contact_street

  # column name
  billing_contact_title

  # column name
  billing_country

  # column name
  billing_postal_code

  # column name
  billing_region_state

  # column name
  billing_street

  # column name
  channel

  # column name
  channel_blocks

  # column name
  child_pixel_id

  # column name
  click_attribution_window

  # column name
  click_lift_percentage

  # column name
  connection_method

  # column name
  created_at

  # column name
  credit_limit

  # column name
  currency

  # column name
  destination_country

  # column name
  destination_postal_code

  # column name
  external_id

  # column name
  id

  # column name
  integration_contact_email

  # column name
  integration_contact_name

  # column name
  integration_contact_phone_number

  # column name
  integration_contact_title

  # column name
  inventory_whitelist_blacklist

  # column name
  market_area_cities

  # column name
  market_area_countries

  # column name
  name

  # column name
  parent_account_id

  # column name
  parent_pixel_id

  # column name
  payment_method

  # column name
  payment_terms

  # column name
  region

  # column name
  sales_rep

  # column name
  sfdc_account_id

  # column name
  status

  # column name
  tags

  # column name
  tier

  # column name
  time_zone

  # column name
  type

  # column name
  updated_at

  # column name
  vertical

  # column name
  vertical_blocks

  # column name
  view_attribution_window

  # column name
  view_lift_percentage
}

# input type for updating data in table "accounts"
input accounts_set_input {
  account_manager: String
  advertiser_blocks: String
  bill_to: String
  billing_city: String
  billing_contact_city: String
  billing_contact_country: String
  billing_contact_email: String
  billing_contact_name: String
  billing_contact_phone_number: String
  billing_contact_postal_code: String
  billing_contact_region_state: String
  billing_contact_street: String
  billing_contact_title: String
  billing_country: String
  billing_postal_code: String
  billing_region_state: String
  billing_street: String
  channel: String
  channel_blocks: String
  child_pixel_id: Int
  click_attribution_window: smallint
  click_lift_percentage: numeric
  connection_method: String
  created_at: timestamptz
  credit_limit: String
  currency: String
  destination_country: String
  destination_postal_code: String
  external_id: Int
  id: Int
  integration_contact_email: String
  integration_contact_name: String
  integration_contact_phone_number: String
  integration_contact_title: String
  inventory_whitelist_blacklist: String
  market_area_cities: String
  market_area_countries: String
  name: String
  parent_account_id: Int
  parent_pixel_id: Int
  payment_method: String
  payment_terms: String
  region: String
  sales_rep: String
  sfdc_account_id: Int
  status: String
  tags: String
  tier: String
  time_zone: String
  type: String
  updated_at: timestamptz
  vertical: String
  vertical_blocks: String
  view_attribution_window: smallint
  view_lift_percentage: numeric
}

# aggregate stddev on columns
type accounts_stddev_fields {
  child_pixel_id: Float
  click_attribution_window: Float
  click_lift_percentage: Float
  external_id: Float
  id: Float
  parent_account_id: Float
  parent_pixel_id: Float
  sfdc_account_id: Float
  view_attribution_window: Float
  view_lift_percentage: Float
}

# order by stddev() on columns of table "accounts"
input accounts_stddev_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# aggregate stddev_pop on columns
type accounts_stddev_pop_fields {
  child_pixel_id: Float
  click_attribution_window: Float
  click_lift_percentage: Float
  external_id: Float
  id: Float
  parent_account_id: Float
  parent_pixel_id: Float
  sfdc_account_id: Float
  view_attribution_window: Float
  view_lift_percentage: Float
}

# order by stddev_pop() on columns of table "accounts"
input accounts_stddev_pop_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# aggregate stddev_samp on columns
type accounts_stddev_samp_fields {
  child_pixel_id: Float
  click_attribution_window: Float
  click_lift_percentage: Float
  external_id: Float
  id: Float
  parent_account_id: Float
  parent_pixel_id: Float
  sfdc_account_id: Float
  view_attribution_window: Float
  view_lift_percentage: Float
}

# order by stddev_samp() on columns of table "accounts"
input accounts_stddev_samp_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# aggregate sum on columns
type accounts_sum_fields {
  child_pixel_id: Int
  click_attribution_window: smallint
  click_lift_percentage: numeric
  external_id: Int
  id: Int
  parent_account_id: Int
  parent_pixel_id: Int
  sfdc_account_id: Int
  view_attribution_window: smallint
  view_lift_percentage: numeric
}

# order by sum() on columns of table "accounts"
input accounts_sum_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# update columns of table "accounts"
enum accounts_update_column {
  # column name
  account_manager

  # column name
  advertiser_blocks

  # column name
  bill_to

  # column name
  billing_city

  # column name
  billing_contact_city

  # column name
  billing_contact_country

  # column name
  billing_contact_email

  # column name
  billing_contact_name

  # column name
  billing_contact_phone_number

  # column name
  billing_contact_postal_code

  # column name
  billing_contact_region_state

  # column name
  billing_contact_street

  # column name
  billing_contact_title

  # column name
  billing_country

  # column name
  billing_postal_code

  # column name
  billing_region_state

  # column name
  billing_street

  # column name
  channel

  # column name
  channel_blocks

  # column name
  child_pixel_id

  # column name
  click_attribution_window

  # column name
  click_lift_percentage

  # column name
  connection_method

  # column name
  created_at

  # column name
  credit_limit

  # column name
  currency

  # column name
  destination_country

  # column name
  destination_postal_code

  # column name
  external_id

  # column name
  id

  # column name
  integration_contact_email

  # column name
  integration_contact_name

  # column name
  integration_contact_phone_number

  # column name
  integration_contact_title

  # column name
  inventory_whitelist_blacklist

  # column name
  market_area_cities

  # column name
  market_area_countries

  # column name
  name

  # column name
  parent_account_id

  # column name
  parent_pixel_id

  # column name
  payment_method

  # column name
  payment_terms

  # column name
  region

  # column name
  sales_rep

  # column name
  sfdc_account_id

  # column name
  status

  # column name
  tags

  # column name
  tier

  # column name
  time_zone

  # column name
  type

  # column name
  updated_at

  # column name
  vertical

  # column name
  vertical_blocks

  # column name
  view_attribution_window

  # column name
  view_lift_percentage
}

# aggregate var_pop on columns
type accounts_var_pop_fields {
  child_pixel_id: Float
  click_attribution_window: Float
  click_lift_percentage: Float
  external_id: Float
  id: Float
  parent_account_id: Float
  parent_pixel_id: Float
  sfdc_account_id: Float
  view_attribution_window: Float
  view_lift_percentage: Float
}

# order by var_pop() on columns of table "accounts"
input accounts_var_pop_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# aggregate var_samp on columns
type accounts_var_samp_fields {
  child_pixel_id: Float
  click_attribution_window: Float
  click_lift_percentage: Float
  external_id: Float
  id: Float
  parent_account_id: Float
  parent_pixel_id: Float
  sfdc_account_id: Float
  view_attribution_window: Float
  view_lift_percentage: Float
}

# order by var_samp() on columns of table "accounts"
input accounts_var_samp_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# aggregate variance on columns
type accounts_variance_fields {
  child_pixel_id: Float
  click_attribution_window: Float
  click_lift_percentage: Float
  external_id: Float
  id: Float
  parent_account_id: Float
  parent_pixel_id: Float
  sfdc_account_id: Float
  view_attribution_window: Float
  view_lift_percentage: Float
}

# order by variance() on columns of table "accounts"
input accounts_variance_order_by {
  child_pixel_id: order_by
  click_attribution_window: order_by
  click_lift_percentage: order_by
  external_id: order_by
  id: order_by
  parent_account_id: order_by
  parent_pixel_id: order_by
  sfdc_account_id: order_by
  view_attribution_window: order_by
  view_lift_percentage: order_by
}

# columns and relationships of "campaigns"
type campaigns {
  # An object relationship
  contract: contracts
  contract_id: Int
  created_at: timestamptz!
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int!
  name: String!
  status: String

  # An array relationship
  tactics(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): [tactics!]!

  # An aggregated array relationship
  tactics_aggregate(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): tactics_aggregate!
  updated_at: timestamptz!
}

# aggregated selection of "campaigns"
type campaigns_aggregate {
  aggregate: campaigns_aggregate_fields
  nodes: [campaigns!]!
}

# aggregate fields of "campaigns"
type campaigns_aggregate_fields {
  avg: campaigns_avg_fields
  count(columns: [campaigns_select_column!], distinct: Boolean): Int
  max: campaigns_max_fields
  min: campaigns_min_fields
  stddev: campaigns_stddev_fields
  stddev_pop: campaigns_stddev_pop_fields
  stddev_samp: campaigns_stddev_samp_fields
  sum: campaigns_sum_fields
  var_pop: campaigns_var_pop_fields
  var_samp: campaigns_var_samp_fields
  variance: campaigns_variance_fields
}

# order by aggregate values of table "campaigns"
input campaigns_aggregate_order_by {
  avg: campaigns_avg_order_by
  count: order_by
  max: campaigns_max_order_by
  min: campaigns_min_order_by
  stddev: campaigns_stddev_order_by
  stddev_pop: campaigns_stddev_pop_order_by
  stddev_samp: campaigns_stddev_samp_order_by
  sum: campaigns_sum_order_by
  var_pop: campaigns_var_pop_order_by
  var_samp: campaigns_var_samp_order_by
  variance: campaigns_variance_order_by
}

# input type for inserting array relation for remote table "campaigns"
input campaigns_arr_rel_insert_input {
  data: [campaigns_insert_input!]!
  on_conflict: campaigns_on_conflict
}

# aggregate avg on columns
type campaigns_avg_fields {
  contract_id: Float
  id: Float
}

# order by avg() on columns of table "campaigns"
input campaigns_avg_order_by {
  contract_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "campaigns". All fields are combined with a logical 'AND'.
input campaigns_bool_exp {
  _and: [campaigns_bool_exp]
  _not: campaigns_bool_exp
  _or: [campaigns_bool_exp]
  contract: contracts_bool_exp
  contract_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  goal_optimization_event: String_comparison_exp
  goal_rate: String_comparison_exp
  goal_type: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  status: String_comparison_exp
  tactics: tactics_bool_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "campaigns"
enum campaigns_constraint {
  # unique or primary key constraint
  campaigns_pkey
}

# input type for incrementing integer column in table "campaigns"
input campaigns_inc_input {
  contract_id: Int
  id: Int
}

# input type for inserting data into table "campaigns"
input campaigns_insert_input {
  contract: contracts_obj_rel_insert_input
  contract_id: Int
  created_at: timestamptz
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  name: String
  status: String
  tactics: tactics_arr_rel_insert_input
  updated_at: timestamptz
}

# aggregate max on columns
type campaigns_max_fields {
  contract_id: Int
  created_at: timestamptz
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  name: String
  status: String
  updated_at: timestamptz
}

# order by max() on columns of table "campaigns"
input campaigns_max_order_by {
  contract_id: order_by
  created_at: order_by
  goal_optimization_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  name: order_by
  status: order_by
  updated_at: order_by
}

# aggregate min on columns
type campaigns_min_fields {
  contract_id: Int
  created_at: timestamptz
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  name: String
  status: String
  updated_at: timestamptz
}

# order by min() on columns of table "campaigns"
input campaigns_min_order_by {
  contract_id: order_by
  created_at: order_by
  goal_optimization_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  name: order_by
  status: order_by
  updated_at: order_by
}

# response of any mutation on the table "campaigns"
type campaigns_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [campaigns!]!
}

# input type for inserting object relation for remote table "campaigns"
input campaigns_obj_rel_insert_input {
  data: campaigns_insert_input!
  on_conflict: campaigns_on_conflict
}

# on conflict condition type for table "campaigns"
input campaigns_on_conflict {
  constraint: campaigns_constraint!
  update_columns: [campaigns_update_column!]!
  where: campaigns_bool_exp
}

# ordering options when selecting data from "campaigns"
input campaigns_order_by {
  contract: contracts_order_by
  contract_id: order_by
  created_at: order_by
  goal_optimization_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  name: order_by
  status: order_by
  tactics_aggregate: tactics_aggregate_order_by
  updated_at: order_by
}

# primary key columns input for table: "campaigns"
input campaigns_pk_columns_input {
  id: Int!
}

# select columns of table "campaigns"
enum campaigns_select_column {
  # column name
  contract_id

  # column name
  created_at

  # column name
  goal_optimization_event

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  name

  # column name
  status

  # column name
  updated_at
}

# input type for updating data in table "campaigns"
input campaigns_set_input {
  contract_id: Int
  created_at: timestamptz
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  name: String
  status: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type campaigns_stddev_fields {
  contract_id: Float
  id: Float
}

# order by stddev() on columns of table "campaigns"
input campaigns_stddev_order_by {
  contract_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type campaigns_stddev_pop_fields {
  contract_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "campaigns"
input campaigns_stddev_pop_order_by {
  contract_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type campaigns_stddev_samp_fields {
  contract_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "campaigns"
input campaigns_stddev_samp_order_by {
  contract_id: order_by
  id: order_by
}

# aggregate sum on columns
type campaigns_sum_fields {
  contract_id: Int
  id: Int
}

# order by sum() on columns of table "campaigns"
input campaigns_sum_order_by {
  contract_id: order_by
  id: order_by
}

# update columns of table "campaigns"
enum campaigns_update_column {
  # column name
  contract_id

  # column name
  created_at

  # column name
  goal_optimization_event

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  name

  # column name
  status

  # column name
  updated_at
}

# aggregate var_pop on columns
type campaigns_var_pop_fields {
  contract_id: Float
  id: Float
}

# order by var_pop() on columns of table "campaigns"
input campaigns_var_pop_order_by {
  contract_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type campaigns_var_samp_fields {
  contract_id: Float
  id: Float
}

# order by var_samp() on columns of table "campaigns"
input campaigns_var_samp_order_by {
  contract_id: order_by
  id: order_by
}

# aggregate variance on columns
type campaigns_variance_fields {
  contract_id: Float
  id: Float
}

# order by variance() on columns of table "campaigns"
input campaigns_variance_order_by {
  contract_id: order_by
  id: order_by
}

# columns and relationships of "channel_sets"
type channel_sets {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  channel: String

  # An object relationship
  contract_line_item: contract_line_items
  contract_line_item_id: Int
  created_at: timestamptz!

  # An array relationship
  creatives(
    # distinct select on columns
    distinct_on: [creatives_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [creatives_order_by!]

    # filter the rows returned
    where: creatives_bool_exp
  ): [creatives!]!

  # An aggregated array relationship
  creatives_aggregate(
    # distinct select on columns
    distinct_on: [creatives_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [creatives_order_by!]

    # filter the rows returned
    where: creatives_bool_exp
  ): creatives_aggregate!
  daily_cap: String
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int!
  inventory_type: String
  name: String!

  # An array relationship
  optimization_modules(
    # distinct select on columns
    distinct_on: [optimization_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [optimization_modules_order_by!]

    # filter the rows returned
    where: optimization_modules_bool_exp
  ): [optimization_modules!]!

  # An aggregated array relationship
  optimization_modules_aggregate(
    # distinct select on columns
    distinct_on: [optimization_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [optimization_modules_order_by!]

    # filter the rows returned
    where: optimization_modules_bool_exp
  ): optimization_modules_aggregate!
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String

  # An array relationship
  setup_modules(
    # distinct select on columns
    distinct_on: [setup_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [setup_modules_order_by!]

    # filter the rows returned
    where: setup_modules_bool_exp
  ): [setup_modules!]!

  # An aggregated array relationship
  setup_modules_aggregate(
    # distinct select on columns
    distinct_on: [setup_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [setup_modules_order_by!]

    # filter the rows returned
    where: setup_modules_bool_exp
  ): setup_modules_aggregate!
  special_pmp_packages: String
  start_date: timestamptz
  status: String

  # An object relationship
  tactic: tactics
  tactic_id: Int
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_state_regions: String
  target_zips: String

  # An array relationship
  traveler_segments(
    # distinct select on columns
    distinct_on: [traveler_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [traveler_segments_order_by!]

    # filter the rows returned
    where: traveler_segments_bool_exp
  ): [traveler_segments!]!

  # An aggregated array relationship
  traveler_segments_aggregate(
    # distinct select on columns
    distinct_on: [traveler_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [traveler_segments_order_by!]

    # filter the rows returned
    where: traveler_segments_bool_exp
  ): traveler_segments_aggregate!
  updated_at: timestamptz!
  viewability_target_percentage: String
  volume: String
  white_list_or_black_list: String
}

# aggregated selection of "channel_sets"
type channel_sets_aggregate {
  aggregate: channel_sets_aggregate_fields
  nodes: [channel_sets!]!
}

# aggregate fields of "channel_sets"
type channel_sets_aggregate_fields {
  avg: channel_sets_avg_fields
  count(columns: [channel_sets_select_column!], distinct: Boolean): Int
  max: channel_sets_max_fields
  min: channel_sets_min_fields
  stddev: channel_sets_stddev_fields
  stddev_pop: channel_sets_stddev_pop_fields
  stddev_samp: channel_sets_stddev_samp_fields
  sum: channel_sets_sum_fields
  var_pop: channel_sets_var_pop_fields
  var_samp: channel_sets_var_samp_fields
  variance: channel_sets_variance_fields
}

# order by aggregate values of table "channel_sets"
input channel_sets_aggregate_order_by {
  avg: channel_sets_avg_order_by
  count: order_by
  max: channel_sets_max_order_by
  min: channel_sets_min_order_by
  stddev: channel_sets_stddev_order_by
  stddev_pop: channel_sets_stddev_pop_order_by
  stddev_samp: channel_sets_stddev_samp_order_by
  sum: channel_sets_sum_order_by
  var_pop: channel_sets_var_pop_order_by
  var_samp: channel_sets_var_samp_order_by
  variance: channel_sets_variance_order_by
}

# input type for inserting array relation for remote table "channel_sets"
input channel_sets_arr_rel_insert_input {
  data: [channel_sets_insert_input!]!
  on_conflict: channel_sets_on_conflict
}

# aggregate avg on columns
type channel_sets_avg_fields {
  contract_line_item_id: Float
  exclude_current_customers: Float
  id: Float
  recency_max: Float
  recency_min: Float
  tactic_id: Float
}

# order by avg() on columns of table "channel_sets"
input channel_sets_avg_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# Boolean expression to filter rows from the table "channel_sets". All fields are combined with a logical 'AND'.
input channel_sets_bool_exp {
  _and: [channel_sets_bool_exp]
  _not: channel_sets_bool_exp
  _or: [channel_sets_bool_exp]
  brand_safety_packages: String_comparison_exp
  budget_impressions: String_comparison_exp
  budget_spend: String_comparison_exp
  channel: String_comparison_exp
  contract_line_item: contract_line_items_bool_exp
  contract_line_item_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  creatives: creatives_bool_exp
  daily_cap: String_comparison_exp
  daypart: String_comparison_exp
  end_date: timestamptz_comparison_exp
  exclude_current_customers: Int_comparison_exp
  flight_schedule: String_comparison_exp
  frequency_cap: String_comparison_exp
  frequency_cap_time_range: String_comparison_exp
  frequency_hard_cap: String_comparison_exp
  goal_optimization_event: String_comparison_exp
  goal_rate: String_comparison_exp
  goal_type: String_comparison_exp
  id: Int_comparison_exp
  inventory_type: String_comparison_exp
  name: String_comparison_exp
  optimization_modules: optimization_modules_bool_exp
  recency_max: Int_comparison_exp
  recency_max_time: String_comparison_exp
  recency_min: Int_comparison_exp
  recency_min_time: String_comparison_exp
  setup_modules: setup_modules_bool_exp
  special_pmp_packages: String_comparison_exp
  start_date: timestamptz_comparison_exp
  status: String_comparison_exp
  tactic: tactics_bool_exp
  tactic_id: Int_comparison_exp
  target_countries: String_comparison_exp
  target_dm_as: String_comparison_exp
  target_languages: String_comparison_exp
  target_state_regions: String_comparison_exp
  target_zips: String_comparison_exp
  traveler_segments: traveler_segments_bool_exp
  updated_at: timestamptz_comparison_exp
  viewability_target_percentage: String_comparison_exp
  volume: String_comparison_exp
  white_list_or_black_list: String_comparison_exp
}

# unique or primary key constraints on table "channel_sets"
enum channel_sets_constraint {
  # unique or primary key constraint
  channel_sets_pkey
}

# input type for incrementing integer column in table "channel_sets"
input channel_sets_inc_input {
  contract_line_item_id: Int
  exclude_current_customers: Int
  id: Int
  recency_max: Int
  recency_min: Int
  tactic_id: Int
}

# input type for inserting data into table "channel_sets"
input channel_sets_insert_input {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  channel: String
  contract_line_item: contract_line_items_obj_rel_insert_input
  contract_line_item_id: Int
  created_at: timestamptz
  creatives: creatives_arr_rel_insert_input
  daily_cap: String
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  name: String
  optimization_modules: optimization_modules_arr_rel_insert_input
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  setup_modules: setup_modules_arr_rel_insert_input
  special_pmp_packages: String
  start_date: timestamptz
  status: String
  tactic: tactics_obj_rel_insert_input
  tactic_id: Int
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_state_regions: String
  target_zips: String
  traveler_segments: traveler_segments_arr_rel_insert_input
  updated_at: timestamptz
  viewability_target_percentage: String
  volume: String
  white_list_or_black_list: String
}

# aggregate max on columns
type channel_sets_max_fields {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  channel: String
  contract_line_item_id: Int
  created_at: timestamptz
  daily_cap: String
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  name: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  special_pmp_packages: String
  start_date: timestamptz
  status: String
  tactic_id: Int
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_state_regions: String
  target_zips: String
  updated_at: timestamptz
  viewability_target_percentage: String
  volume: String
  white_list_or_black_list: String
}

# order by max() on columns of table "channel_sets"
input channel_sets_max_order_by {
  brand_safety_packages: order_by
  budget_impressions: order_by
  budget_spend: order_by
  channel: order_by
  contract_line_item_id: order_by
  created_at: order_by
  daily_cap: order_by
  daypart: order_by
  end_date: order_by
  exclude_current_customers: order_by
  flight_schedule: order_by
  frequency_cap: order_by
  frequency_cap_time_range: order_by
  frequency_hard_cap: order_by
  goal_optimization_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  inventory_type: order_by
  name: order_by
  recency_max: order_by
  recency_max_time: order_by
  recency_min: order_by
  recency_min_time: order_by
  special_pmp_packages: order_by
  start_date: order_by
  status: order_by
  tactic_id: order_by
  target_countries: order_by
  target_dm_as: order_by
  target_languages: order_by
  target_state_regions: order_by
  target_zips: order_by
  updated_at: order_by
  viewability_target_percentage: order_by
  volume: order_by
  white_list_or_black_list: order_by
}

# aggregate min on columns
type channel_sets_min_fields {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  channel: String
  contract_line_item_id: Int
  created_at: timestamptz
  daily_cap: String
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  name: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  special_pmp_packages: String
  start_date: timestamptz
  status: String
  tactic_id: Int
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_state_regions: String
  target_zips: String
  updated_at: timestamptz
  viewability_target_percentage: String
  volume: String
  white_list_or_black_list: String
}

# order by min() on columns of table "channel_sets"
input channel_sets_min_order_by {
  brand_safety_packages: order_by
  budget_impressions: order_by
  budget_spend: order_by
  channel: order_by
  contract_line_item_id: order_by
  created_at: order_by
  daily_cap: order_by
  daypart: order_by
  end_date: order_by
  exclude_current_customers: order_by
  flight_schedule: order_by
  frequency_cap: order_by
  frequency_cap_time_range: order_by
  frequency_hard_cap: order_by
  goal_optimization_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  inventory_type: order_by
  name: order_by
  recency_max: order_by
  recency_max_time: order_by
  recency_min: order_by
  recency_min_time: order_by
  special_pmp_packages: order_by
  start_date: order_by
  status: order_by
  tactic_id: order_by
  target_countries: order_by
  target_dm_as: order_by
  target_languages: order_by
  target_state_regions: order_by
  target_zips: order_by
  updated_at: order_by
  viewability_target_percentage: order_by
  volume: order_by
  white_list_or_black_list: order_by
}

# response of any mutation on the table "channel_sets"
type channel_sets_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [channel_sets!]!
}

# input type for inserting object relation for remote table "channel_sets"
input channel_sets_obj_rel_insert_input {
  data: channel_sets_insert_input!
  on_conflict: channel_sets_on_conflict
}

# on conflict condition type for table "channel_sets"
input channel_sets_on_conflict {
  constraint: channel_sets_constraint!
  update_columns: [channel_sets_update_column!]!
  where: channel_sets_bool_exp
}

# ordering options when selecting data from "channel_sets"
input channel_sets_order_by {
  brand_safety_packages: order_by
  budget_impressions: order_by
  budget_spend: order_by
  channel: order_by
  contract_line_item: contract_line_items_order_by
  contract_line_item_id: order_by
  created_at: order_by
  creatives_aggregate: creatives_aggregate_order_by
  daily_cap: order_by
  daypart: order_by
  end_date: order_by
  exclude_current_customers: order_by
  flight_schedule: order_by
  frequency_cap: order_by
  frequency_cap_time_range: order_by
  frequency_hard_cap: order_by
  goal_optimization_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  inventory_type: order_by
  name: order_by
  optimization_modules_aggregate: optimization_modules_aggregate_order_by
  recency_max: order_by
  recency_max_time: order_by
  recency_min: order_by
  recency_min_time: order_by
  setup_modules_aggregate: setup_modules_aggregate_order_by
  special_pmp_packages: order_by
  start_date: order_by
  status: order_by
  tactic: tactics_order_by
  tactic_id: order_by
  target_countries: order_by
  target_dm_as: order_by
  target_languages: order_by
  target_state_regions: order_by
  target_zips: order_by
  traveler_segments_aggregate: traveler_segments_aggregate_order_by
  updated_at: order_by
  viewability_target_percentage: order_by
  volume: order_by
  white_list_or_black_list: order_by
}

# primary key columns input for table: "channel_sets"
input channel_sets_pk_columns_input {
  id: Int!
}

# select columns of table "channel_sets"
enum channel_sets_select_column {
  # column name
  brand_safety_packages

  # column name
  budget_impressions

  # column name
  budget_spend

  # column name
  channel

  # column name
  contract_line_item_id

  # column name
  created_at

  # column name
  daily_cap

  # column name
  daypart

  # column name
  end_date

  # column name
  exclude_current_customers

  # column name
  flight_schedule

  # column name
  frequency_cap

  # column name
  frequency_cap_time_range

  # column name
  frequency_hard_cap

  # column name
  goal_optimization_event

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  inventory_type

  # column name
  name

  # column name
  recency_max

  # column name
  recency_max_time

  # column name
  recency_min

  # column name
  recency_min_time

  # column name
  special_pmp_packages

  # column name
  start_date

  # column name
  status

  # column name
  tactic_id

  # column name
  target_countries

  # column name
  target_dm_as

  # column name
  target_languages

  # column name
  target_state_regions

  # column name
  target_zips

  # column name
  updated_at

  # column name
  viewability_target_percentage

  # column name
  volume

  # column name
  white_list_or_black_list
}

# input type for updating data in table "channel_sets"
input channel_sets_set_input {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  channel: String
  contract_line_item_id: Int
  created_at: timestamptz
  daily_cap: String
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_optimization_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  name: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  special_pmp_packages: String
  start_date: timestamptz
  status: String
  tactic_id: Int
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_state_regions: String
  target_zips: String
  updated_at: timestamptz
  viewability_target_percentage: String
  volume: String
  white_list_or_black_list: String
}

# aggregate stddev on columns
type channel_sets_stddev_fields {
  contract_line_item_id: Float
  exclude_current_customers: Float
  id: Float
  recency_max: Float
  recency_min: Float
  tactic_id: Float
}

# order by stddev() on columns of table "channel_sets"
input channel_sets_stddev_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# aggregate stddev_pop on columns
type channel_sets_stddev_pop_fields {
  contract_line_item_id: Float
  exclude_current_customers: Float
  id: Float
  recency_max: Float
  recency_min: Float
  tactic_id: Float
}

# order by stddev_pop() on columns of table "channel_sets"
input channel_sets_stddev_pop_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# aggregate stddev_samp on columns
type channel_sets_stddev_samp_fields {
  contract_line_item_id: Float
  exclude_current_customers: Float
  id: Float
  recency_max: Float
  recency_min: Float
  tactic_id: Float
}

# order by stddev_samp() on columns of table "channel_sets"
input channel_sets_stddev_samp_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# aggregate sum on columns
type channel_sets_sum_fields {
  contract_line_item_id: Int
  exclude_current_customers: Int
  id: Int
  recency_max: Int
  recency_min: Int
  tactic_id: Int
}

# order by sum() on columns of table "channel_sets"
input channel_sets_sum_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# update columns of table "channel_sets"
enum channel_sets_update_column {
  # column name
  brand_safety_packages

  # column name
  budget_impressions

  # column name
  budget_spend

  # column name
  channel

  # column name
  contract_line_item_id

  # column name
  created_at

  # column name
  daily_cap

  # column name
  daypart

  # column name
  end_date

  # column name
  exclude_current_customers

  # column name
  flight_schedule

  # column name
  frequency_cap

  # column name
  frequency_cap_time_range

  # column name
  frequency_hard_cap

  # column name
  goal_optimization_event

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  inventory_type

  # column name
  name

  # column name
  recency_max

  # column name
  recency_max_time

  # column name
  recency_min

  # column name
  recency_min_time

  # column name
  special_pmp_packages

  # column name
  start_date

  # column name
  status

  # column name
  tactic_id

  # column name
  target_countries

  # column name
  target_dm_as

  # column name
  target_languages

  # column name
  target_state_regions

  # column name
  target_zips

  # column name
  updated_at

  # column name
  viewability_target_percentage

  # column name
  volume

  # column name
  white_list_or_black_list
}

# aggregate var_pop on columns
type channel_sets_var_pop_fields {
  contract_line_item_id: Float
  exclude_current_customers: Float
  id: Float
  recency_max: Float
  recency_min: Float
  tactic_id: Float
}

# order by var_pop() on columns of table "channel_sets"
input channel_sets_var_pop_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# aggregate var_samp on columns
type channel_sets_var_samp_fields {
  contract_line_item_id: Float
  exclude_current_customers: Float
  id: Float
  recency_max: Float
  recency_min: Float
  tactic_id: Float
}

# order by var_samp() on columns of table "channel_sets"
input channel_sets_var_samp_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# aggregate variance on columns
type channel_sets_variance_fields {
  contract_line_item_id: Float
  exclude_current_customers: Float
  id: Float
  recency_max: Float
  recency_min: Float
  tactic_id: Float
}

# order by variance() on columns of table "channel_sets"
input channel_sets_variance_order_by {
  contract_line_item_id: order_by
  exclude_current_customers: order_by
  id: order_by
  recency_max: order_by
  recency_min: order_by
  tactic_id: order_by
}

# columns and relationships of "contract_line_items"
type contract_line_items {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  calculated_volume: String
  channel: String

  # An array relationship
  channel_sets(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): [channel_sets!]!

  # An aggregated array relationship
  channel_sets_aggregate(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): channel_sets_aggregate!

  # An object relationship
  contract: contracts
  contract_id: Int
  created_at: timestamptz!
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_event: String
  goal_rate: String
  goal_type: String
  id: Int!
  inventory_type: String
  line_item_type: String
  min_margin: String
  name: String!
  notes: String
  promotion_id: Int
  rate: String
  rate_type: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  reporting_source: String
  special_pmp_packages: String
  start_date: timestamptz
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_states_regions: String
  target_zips: String
  updated_at: timestamptz!
  viewability_target_percentage: String
  white_list_black_list: String
}

# aggregated selection of "contract_line_items"
type contract_line_items_aggregate {
  aggregate: contract_line_items_aggregate_fields
  nodes: [contract_line_items!]!
}

# aggregate fields of "contract_line_items"
type contract_line_items_aggregate_fields {
  avg: contract_line_items_avg_fields
  count(columns: [contract_line_items_select_column!], distinct: Boolean): Int
  max: contract_line_items_max_fields
  min: contract_line_items_min_fields
  stddev: contract_line_items_stddev_fields
  stddev_pop: contract_line_items_stddev_pop_fields
  stddev_samp: contract_line_items_stddev_samp_fields
  sum: contract_line_items_sum_fields
  var_pop: contract_line_items_var_pop_fields
  var_samp: contract_line_items_var_samp_fields
  variance: contract_line_items_variance_fields
}

# order by aggregate values of table "contract_line_items"
input contract_line_items_aggregate_order_by {
  avg: contract_line_items_avg_order_by
  count: order_by
  max: contract_line_items_max_order_by
  min: contract_line_items_min_order_by
  stddev: contract_line_items_stddev_order_by
  stddev_pop: contract_line_items_stddev_pop_order_by
  stddev_samp: contract_line_items_stddev_samp_order_by
  sum: contract_line_items_sum_order_by
  var_pop: contract_line_items_var_pop_order_by
  var_samp: contract_line_items_var_samp_order_by
  variance: contract_line_items_variance_order_by
}

# input type for inserting array relation for remote table "contract_line_items"
input contract_line_items_arr_rel_insert_input {
  data: [contract_line_items_insert_input!]!
  on_conflict: contract_line_items_on_conflict
}

# aggregate avg on columns
type contract_line_items_avg_fields {
  contract_id: Float
  exclude_current_customers: Float
  id: Float
  promotion_id: Float
  recency_max: Float
  recency_min: Float
}

# order by avg() on columns of table "contract_line_items"
input contract_line_items_avg_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# Boolean expression to filter rows from the table "contract_line_items". All fields are combined with a logical 'AND'.
input contract_line_items_bool_exp {
  _and: [contract_line_items_bool_exp]
  _not: contract_line_items_bool_exp
  _or: [contract_line_items_bool_exp]
  brand_safety_packages: String_comparison_exp
  budget_impressions: String_comparison_exp
  budget_spend: String_comparison_exp
  calculated_volume: String_comparison_exp
  channel: String_comparison_exp
  channel_sets: channel_sets_bool_exp
  contract: contracts_bool_exp
  contract_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  daypart: String_comparison_exp
  end_date: timestamptz_comparison_exp
  exclude_current_customers: Int_comparison_exp
  flight_schedule: String_comparison_exp
  frequency_cap: String_comparison_exp
  frequency_cap_time_range: String_comparison_exp
  frequency_hard_cap: String_comparison_exp
  goal_event: String_comparison_exp
  goal_rate: String_comparison_exp
  goal_type: String_comparison_exp
  id: Int_comparison_exp
  inventory_type: String_comparison_exp
  line_item_type: String_comparison_exp
  min_margin: String_comparison_exp
  name: String_comparison_exp
  notes: String_comparison_exp
  promotion_id: Int_comparison_exp
  rate: String_comparison_exp
  rate_type: String_comparison_exp
  recency_max: Int_comparison_exp
  recency_max_time: String_comparison_exp
  recency_min: Int_comparison_exp
  recency_min_time: String_comparison_exp
  reporting_source: String_comparison_exp
  special_pmp_packages: String_comparison_exp
  start_date: timestamptz_comparison_exp
  target_countries: String_comparison_exp
  target_dm_as: String_comparison_exp
  target_languages: String_comparison_exp
  target_states_regions: String_comparison_exp
  target_zips: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  viewability_target_percentage: String_comparison_exp
  white_list_black_list: String_comparison_exp
}

# unique or primary key constraints on table "contract_line_items"
enum contract_line_items_constraint {
  # unique or primary key constraint
  contract_line_items_pkey
}

# input type for incrementing integer column in table "contract_line_items"
input contract_line_items_inc_input {
  contract_id: Int
  exclude_current_customers: Int
  id: Int
  promotion_id: Int
  recency_max: Int
  recency_min: Int
}

# input type for inserting data into table "contract_line_items"
input contract_line_items_insert_input {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  calculated_volume: String
  channel: String
  channel_sets: channel_sets_arr_rel_insert_input
  contract: contracts_obj_rel_insert_input
  contract_id: Int
  created_at: timestamptz
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  line_item_type: String
  min_margin: String
  name: String
  notes: String
  promotion_id: Int
  rate: String
  rate_type: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  reporting_source: String
  special_pmp_packages: String
  start_date: timestamptz
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_states_regions: String
  target_zips: String
  updated_at: timestamptz
  viewability_target_percentage: String
  white_list_black_list: String
}

# aggregate max on columns
type contract_line_items_max_fields {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  calculated_volume: String
  channel: String
  contract_id: Int
  created_at: timestamptz
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  line_item_type: String
  min_margin: String
  name: String
  notes: String
  promotion_id: Int
  rate: String
  rate_type: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  reporting_source: String
  special_pmp_packages: String
  start_date: timestamptz
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_states_regions: String
  target_zips: String
  updated_at: timestamptz
  viewability_target_percentage: String
  white_list_black_list: String
}

# order by max() on columns of table "contract_line_items"
input contract_line_items_max_order_by {
  brand_safety_packages: order_by
  budget_impressions: order_by
  budget_spend: order_by
  calculated_volume: order_by
  channel: order_by
  contract_id: order_by
  created_at: order_by
  daypart: order_by
  end_date: order_by
  exclude_current_customers: order_by
  flight_schedule: order_by
  frequency_cap: order_by
  frequency_cap_time_range: order_by
  frequency_hard_cap: order_by
  goal_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  inventory_type: order_by
  line_item_type: order_by
  min_margin: order_by
  name: order_by
  notes: order_by
  promotion_id: order_by
  rate: order_by
  rate_type: order_by
  recency_max: order_by
  recency_max_time: order_by
  recency_min: order_by
  recency_min_time: order_by
  reporting_source: order_by
  special_pmp_packages: order_by
  start_date: order_by
  target_countries: order_by
  target_dm_as: order_by
  target_languages: order_by
  target_states_regions: order_by
  target_zips: order_by
  updated_at: order_by
  viewability_target_percentage: order_by
  white_list_black_list: order_by
}

# aggregate min on columns
type contract_line_items_min_fields {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  calculated_volume: String
  channel: String
  contract_id: Int
  created_at: timestamptz
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  line_item_type: String
  min_margin: String
  name: String
  notes: String
  promotion_id: Int
  rate: String
  rate_type: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  reporting_source: String
  special_pmp_packages: String
  start_date: timestamptz
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_states_regions: String
  target_zips: String
  updated_at: timestamptz
  viewability_target_percentage: String
  white_list_black_list: String
}

# order by min() on columns of table "contract_line_items"
input contract_line_items_min_order_by {
  brand_safety_packages: order_by
  budget_impressions: order_by
  budget_spend: order_by
  calculated_volume: order_by
  channel: order_by
  contract_id: order_by
  created_at: order_by
  daypart: order_by
  end_date: order_by
  exclude_current_customers: order_by
  flight_schedule: order_by
  frequency_cap: order_by
  frequency_cap_time_range: order_by
  frequency_hard_cap: order_by
  goal_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  inventory_type: order_by
  line_item_type: order_by
  min_margin: order_by
  name: order_by
  notes: order_by
  promotion_id: order_by
  rate: order_by
  rate_type: order_by
  recency_max: order_by
  recency_max_time: order_by
  recency_min: order_by
  recency_min_time: order_by
  reporting_source: order_by
  special_pmp_packages: order_by
  start_date: order_by
  target_countries: order_by
  target_dm_as: order_by
  target_languages: order_by
  target_states_regions: order_by
  target_zips: order_by
  updated_at: order_by
  viewability_target_percentage: order_by
  white_list_black_list: order_by
}

# response of any mutation on the table "contract_line_items"
type contract_line_items_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [contract_line_items!]!
}

# input type for inserting object relation for remote table "contract_line_items"
input contract_line_items_obj_rel_insert_input {
  data: contract_line_items_insert_input!
  on_conflict: contract_line_items_on_conflict
}

# on conflict condition type for table "contract_line_items"
input contract_line_items_on_conflict {
  constraint: contract_line_items_constraint!
  update_columns: [contract_line_items_update_column!]!
  where: contract_line_items_bool_exp
}

# ordering options when selecting data from "contract_line_items"
input contract_line_items_order_by {
  brand_safety_packages: order_by
  budget_impressions: order_by
  budget_spend: order_by
  calculated_volume: order_by
  channel: order_by
  channel_sets_aggregate: channel_sets_aggregate_order_by
  contract: contracts_order_by
  contract_id: order_by
  created_at: order_by
  daypart: order_by
  end_date: order_by
  exclude_current_customers: order_by
  flight_schedule: order_by
  frequency_cap: order_by
  frequency_cap_time_range: order_by
  frequency_hard_cap: order_by
  goal_event: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  inventory_type: order_by
  line_item_type: order_by
  min_margin: order_by
  name: order_by
  notes: order_by
  promotion_id: order_by
  rate: order_by
  rate_type: order_by
  recency_max: order_by
  recency_max_time: order_by
  recency_min: order_by
  recency_min_time: order_by
  reporting_source: order_by
  special_pmp_packages: order_by
  start_date: order_by
  target_countries: order_by
  target_dm_as: order_by
  target_languages: order_by
  target_states_regions: order_by
  target_zips: order_by
  updated_at: order_by
  viewability_target_percentage: order_by
  white_list_black_list: order_by
}

# primary key columns input for table: "contract_line_items"
input contract_line_items_pk_columns_input {
  id: Int!
}

# select columns of table "contract_line_items"
enum contract_line_items_select_column {
  # column name
  brand_safety_packages

  # column name
  budget_impressions

  # column name
  budget_spend

  # column name
  calculated_volume

  # column name
  channel

  # column name
  contract_id

  # column name
  created_at

  # column name
  daypart

  # column name
  end_date

  # column name
  exclude_current_customers

  # column name
  flight_schedule

  # column name
  frequency_cap

  # column name
  frequency_cap_time_range

  # column name
  frequency_hard_cap

  # column name
  goal_event

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  inventory_type

  # column name
  line_item_type

  # column name
  min_margin

  # column name
  name

  # column name
  notes

  # column name
  promotion_id

  # column name
  rate

  # column name
  rate_type

  # column name
  recency_max

  # column name
  recency_max_time

  # column name
  recency_min

  # column name
  recency_min_time

  # column name
  reporting_source

  # column name
  special_pmp_packages

  # column name
  start_date

  # column name
  target_countries

  # column name
  target_dm_as

  # column name
  target_languages

  # column name
  target_states_regions

  # column name
  target_zips

  # column name
  updated_at

  # column name
  viewability_target_percentage

  # column name
  white_list_black_list
}

# input type for updating data in table "contract_line_items"
input contract_line_items_set_input {
  brand_safety_packages: String
  budget_impressions: String
  budget_spend: String
  calculated_volume: String
  channel: String
  contract_id: Int
  created_at: timestamptz
  daypart: String
  end_date: timestamptz
  exclude_current_customers: Int
  flight_schedule: String
  frequency_cap: String
  frequency_cap_time_range: String
  frequency_hard_cap: String
  goal_event: String
  goal_rate: String
  goal_type: String
  id: Int
  inventory_type: String
  line_item_type: String
  min_margin: String
  name: String
  notes: String
  promotion_id: Int
  rate: String
  rate_type: String
  recency_max: Int
  recency_max_time: String
  recency_min: Int
  recency_min_time: String
  reporting_source: String
  special_pmp_packages: String
  start_date: timestamptz
  target_countries: String
  target_dm_as: String
  target_languages: String
  target_states_regions: String
  target_zips: String
  updated_at: timestamptz
  viewability_target_percentage: String
  white_list_black_list: String
}

# aggregate stddev on columns
type contract_line_items_stddev_fields {
  contract_id: Float
  exclude_current_customers: Float
  id: Float
  promotion_id: Float
  recency_max: Float
  recency_min: Float
}

# order by stddev() on columns of table "contract_line_items"
input contract_line_items_stddev_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# aggregate stddev_pop on columns
type contract_line_items_stddev_pop_fields {
  contract_id: Float
  exclude_current_customers: Float
  id: Float
  promotion_id: Float
  recency_max: Float
  recency_min: Float
}

# order by stddev_pop() on columns of table "contract_line_items"
input contract_line_items_stddev_pop_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# aggregate stddev_samp on columns
type contract_line_items_stddev_samp_fields {
  contract_id: Float
  exclude_current_customers: Float
  id: Float
  promotion_id: Float
  recency_max: Float
  recency_min: Float
}

# order by stddev_samp() on columns of table "contract_line_items"
input contract_line_items_stddev_samp_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# aggregate sum on columns
type contract_line_items_sum_fields {
  contract_id: Int
  exclude_current_customers: Int
  id: Int
  promotion_id: Int
  recency_max: Int
  recency_min: Int
}

# order by sum() on columns of table "contract_line_items"
input contract_line_items_sum_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# update columns of table "contract_line_items"
enum contract_line_items_update_column {
  # column name
  brand_safety_packages

  # column name
  budget_impressions

  # column name
  budget_spend

  # column name
  calculated_volume

  # column name
  channel

  # column name
  contract_id

  # column name
  created_at

  # column name
  daypart

  # column name
  end_date

  # column name
  exclude_current_customers

  # column name
  flight_schedule

  # column name
  frequency_cap

  # column name
  frequency_cap_time_range

  # column name
  frequency_hard_cap

  # column name
  goal_event

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  inventory_type

  # column name
  line_item_type

  # column name
  min_margin

  # column name
  name

  # column name
  notes

  # column name
  promotion_id

  # column name
  rate

  # column name
  rate_type

  # column name
  recency_max

  # column name
  recency_max_time

  # column name
  recency_min

  # column name
  recency_min_time

  # column name
  reporting_source

  # column name
  special_pmp_packages

  # column name
  start_date

  # column name
  target_countries

  # column name
  target_dm_as

  # column name
  target_languages

  # column name
  target_states_regions

  # column name
  target_zips

  # column name
  updated_at

  # column name
  viewability_target_percentage

  # column name
  white_list_black_list
}

# aggregate var_pop on columns
type contract_line_items_var_pop_fields {
  contract_id: Float
  exclude_current_customers: Float
  id: Float
  promotion_id: Float
  recency_max: Float
  recency_min: Float
}

# order by var_pop() on columns of table "contract_line_items"
input contract_line_items_var_pop_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# aggregate var_samp on columns
type contract_line_items_var_samp_fields {
  contract_id: Float
  exclude_current_customers: Float
  id: Float
  promotion_id: Float
  recency_max: Float
  recency_min: Float
}

# order by var_samp() on columns of table "contract_line_items"
input contract_line_items_var_samp_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# aggregate variance on columns
type contract_line_items_variance_fields {
  contract_id: Float
  exclude_current_customers: Float
  id: Float
  promotion_id: Float
  recency_max: Float
  recency_min: Float
}

# order by variance() on columns of table "contract_line_items"
input contract_line_items_variance_order_by {
  contract_id: order_by
  exclude_current_customers: order_by
  id: order_by
  promotion_id: order_by
  recency_max: order_by
  recency_min: order_by
}

# columns and relationships of "contracts"
type contracts {
  # An object relationship
  account: accounts
  account_id: Int
  bill_to: String
  budget: String

  # An array relationship
  campaigns(
    # distinct select on columns
    distinct_on: [campaigns_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaigns_order_by!]

    # filter the rows returned
    where: campaigns_bool_exp
  ): [campaigns!]!

  # An aggregated array relationship
  campaigns_aggregate(
    # distinct select on columns
    distinct_on: [campaigns_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaigns_order_by!]

    # filter the rows returned
    where: campaigns_bool_exp
  ): campaigns_aggregate!

  # An array relationship
  contract_line_items(
    # distinct select on columns
    distinct_on: [contract_line_items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contract_line_items_order_by!]

    # filter the rows returned
    where: contract_line_items_bool_exp
  ): [contract_line_items!]!

  # An aggregated array relationship
  contract_line_items_aggregate(
    # distinct select on columns
    distinct_on: [contract_line_items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contract_line_items_order_by!]

    # filter the rows returned
    where: contract_line_items_bool_exp
  ): contract_line_items_aggregate!
  created_at: timestamptz!
  currency: String
  end_date: timestamptz
  flight_schedule: String
  id: Int!
  name: String!
  notes: String
  sfdc_opportunity_id: Int
  start_date: timestamptz
  status: String
  tc_version: String
  type: String
  updated_at: timestamptz!
  uploaded_executed_contract_link: String
}

# aggregated selection of "contracts"
type contracts_aggregate {
  aggregate: contracts_aggregate_fields
  nodes: [contracts!]!
}

# aggregate fields of "contracts"
type contracts_aggregate_fields {
  avg: contracts_avg_fields
  count(columns: [contracts_select_column!], distinct: Boolean): Int
  max: contracts_max_fields
  min: contracts_min_fields
  stddev: contracts_stddev_fields
  stddev_pop: contracts_stddev_pop_fields
  stddev_samp: contracts_stddev_samp_fields
  sum: contracts_sum_fields
  var_pop: contracts_var_pop_fields
  var_samp: contracts_var_samp_fields
  variance: contracts_variance_fields
}

# order by aggregate values of table "contracts"
input contracts_aggregate_order_by {
  avg: contracts_avg_order_by
  count: order_by
  max: contracts_max_order_by
  min: contracts_min_order_by
  stddev: contracts_stddev_order_by
  stddev_pop: contracts_stddev_pop_order_by
  stddev_samp: contracts_stddev_samp_order_by
  sum: contracts_sum_order_by
  var_pop: contracts_var_pop_order_by
  var_samp: contracts_var_samp_order_by
  variance: contracts_variance_order_by
}

# input type for inserting array relation for remote table "contracts"
input contracts_arr_rel_insert_input {
  data: [contracts_insert_input!]!
  on_conflict: contracts_on_conflict
}

# aggregate avg on columns
type contracts_avg_fields {
  account_id: Float
  id: Float
  sfdc_opportunity_id: Float
}

# order by avg() on columns of table "contracts"
input contracts_avg_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# Boolean expression to filter rows from the table "contracts". All fields are combined with a logical 'AND'.
input contracts_bool_exp {
  _and: [contracts_bool_exp]
  _not: contracts_bool_exp
  _or: [contracts_bool_exp]
  account: accounts_bool_exp
  account_id: Int_comparison_exp
  bill_to: String_comparison_exp
  budget: String_comparison_exp
  campaigns: campaigns_bool_exp
  contract_line_items: contract_line_items_bool_exp
  created_at: timestamptz_comparison_exp
  currency: String_comparison_exp
  end_date: timestamptz_comparison_exp
  flight_schedule: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  notes: String_comparison_exp
  sfdc_opportunity_id: Int_comparison_exp
  start_date: timestamptz_comparison_exp
  status: String_comparison_exp
  tc_version: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  uploaded_executed_contract_link: String_comparison_exp
}

# unique or primary key constraints on table "contracts"
enum contracts_constraint {
  # unique or primary key constraint
  contracts_pkey
}

# input type for incrementing integer column in table "contracts"
input contracts_inc_input {
  account_id: Int
  id: Int
  sfdc_opportunity_id: Int
}

# input type for inserting data into table "contracts"
input contracts_insert_input {
  account: accounts_obj_rel_insert_input
  account_id: Int
  bill_to: String
  budget: String
  campaigns: campaigns_arr_rel_insert_input
  contract_line_items: contract_line_items_arr_rel_insert_input
  created_at: timestamptz
  currency: String
  end_date: timestamptz
  flight_schedule: String
  id: Int
  name: String
  notes: String
  sfdc_opportunity_id: Int
  start_date: timestamptz
  status: String
  tc_version: String
  type: String
  updated_at: timestamptz
  uploaded_executed_contract_link: String
}

# aggregate max on columns
type contracts_max_fields {
  account_id: Int
  bill_to: String
  budget: String
  created_at: timestamptz
  currency: String
  end_date: timestamptz
  flight_schedule: String
  id: Int
  name: String
  notes: String
  sfdc_opportunity_id: Int
  start_date: timestamptz
  status: String
  tc_version: String
  type: String
  updated_at: timestamptz
  uploaded_executed_contract_link: String
}

# order by max() on columns of table "contracts"
input contracts_max_order_by {
  account_id: order_by
  bill_to: order_by
  budget: order_by
  created_at: order_by
  currency: order_by
  end_date: order_by
  flight_schedule: order_by
  id: order_by
  name: order_by
  notes: order_by
  sfdc_opportunity_id: order_by
  start_date: order_by
  status: order_by
  tc_version: order_by
  type: order_by
  updated_at: order_by
  uploaded_executed_contract_link: order_by
}

# aggregate min on columns
type contracts_min_fields {
  account_id: Int
  bill_to: String
  budget: String
  created_at: timestamptz
  currency: String
  end_date: timestamptz
  flight_schedule: String
  id: Int
  name: String
  notes: String
  sfdc_opportunity_id: Int
  start_date: timestamptz
  status: String
  tc_version: String
  type: String
  updated_at: timestamptz
  uploaded_executed_contract_link: String
}

# order by min() on columns of table "contracts"
input contracts_min_order_by {
  account_id: order_by
  bill_to: order_by
  budget: order_by
  created_at: order_by
  currency: order_by
  end_date: order_by
  flight_schedule: order_by
  id: order_by
  name: order_by
  notes: order_by
  sfdc_opportunity_id: order_by
  start_date: order_by
  status: order_by
  tc_version: order_by
  type: order_by
  updated_at: order_by
  uploaded_executed_contract_link: order_by
}

# response of any mutation on the table "contracts"
type contracts_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [contracts!]!
}

# input type for inserting object relation for remote table "contracts"
input contracts_obj_rel_insert_input {
  data: contracts_insert_input!
  on_conflict: contracts_on_conflict
}

# on conflict condition type for table "contracts"
input contracts_on_conflict {
  constraint: contracts_constraint!
  update_columns: [contracts_update_column!]!
  where: contracts_bool_exp
}

# ordering options when selecting data from "contracts"
input contracts_order_by {
  account: accounts_order_by
  account_id: order_by
  bill_to: order_by
  budget: order_by
  campaigns_aggregate: campaigns_aggregate_order_by
  contract_line_items_aggregate: contract_line_items_aggregate_order_by
  created_at: order_by
  currency: order_by
  end_date: order_by
  flight_schedule: order_by
  id: order_by
  name: order_by
  notes: order_by
  sfdc_opportunity_id: order_by
  start_date: order_by
  status: order_by
  tc_version: order_by
  type: order_by
  updated_at: order_by
  uploaded_executed_contract_link: order_by
}

# primary key columns input for table: "contracts"
input contracts_pk_columns_input {
  id: Int!
}

# select columns of table "contracts"
enum contracts_select_column {
  # column name
  account_id

  # column name
  bill_to

  # column name
  budget

  # column name
  created_at

  # column name
  currency

  # column name
  end_date

  # column name
  flight_schedule

  # column name
  id

  # column name
  name

  # column name
  notes

  # column name
  sfdc_opportunity_id

  # column name
  start_date

  # column name
  status

  # column name
  tc_version

  # column name
  type

  # column name
  updated_at

  # column name
  uploaded_executed_contract_link
}

# input type for updating data in table "contracts"
input contracts_set_input {
  account_id: Int
  bill_to: String
  budget: String
  created_at: timestamptz
  currency: String
  end_date: timestamptz
  flight_schedule: String
  id: Int
  name: String
  notes: String
  sfdc_opportunity_id: Int
  start_date: timestamptz
  status: String
  tc_version: String
  type: String
  updated_at: timestamptz
  uploaded_executed_contract_link: String
}

# aggregate stddev on columns
type contracts_stddev_fields {
  account_id: Float
  id: Float
  sfdc_opportunity_id: Float
}

# order by stddev() on columns of table "contracts"
input contracts_stddev_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# aggregate stddev_pop on columns
type contracts_stddev_pop_fields {
  account_id: Float
  id: Float
  sfdc_opportunity_id: Float
}

# order by stddev_pop() on columns of table "contracts"
input contracts_stddev_pop_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# aggregate stddev_samp on columns
type contracts_stddev_samp_fields {
  account_id: Float
  id: Float
  sfdc_opportunity_id: Float
}

# order by stddev_samp() on columns of table "contracts"
input contracts_stddev_samp_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# aggregate sum on columns
type contracts_sum_fields {
  account_id: Int
  id: Int
  sfdc_opportunity_id: Int
}

# order by sum() on columns of table "contracts"
input contracts_sum_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# update columns of table "contracts"
enum contracts_update_column {
  # column name
  account_id

  # column name
  bill_to

  # column name
  budget

  # column name
  created_at

  # column name
  currency

  # column name
  end_date

  # column name
  flight_schedule

  # column name
  id

  # column name
  name

  # column name
  notes

  # column name
  sfdc_opportunity_id

  # column name
  start_date

  # column name
  status

  # column name
  tc_version

  # column name
  type

  # column name
  updated_at

  # column name
  uploaded_executed_contract_link
}

# aggregate var_pop on columns
type contracts_var_pop_fields {
  account_id: Float
  id: Float
  sfdc_opportunity_id: Float
}

# order by var_pop() on columns of table "contracts"
input contracts_var_pop_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# aggregate var_samp on columns
type contracts_var_samp_fields {
  account_id: Float
  id: Float
  sfdc_opportunity_id: Float
}

# order by var_samp() on columns of table "contracts"
input contracts_var_samp_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# aggregate variance on columns
type contracts_variance_fields {
  account_id: Float
  id: Float
  sfdc_opportunity_id: Float
}

# order by variance() on columns of table "contracts"
input contracts_variance_order_by {
  account_id: order_by
  id: order_by
  sfdc_opportunity_id: order_by
}

# columns and relationships of "creatives"
type creatives {
  # An object relationship
  channel_set: channel_sets
  channel_set_id: Int
  click_tracking_tag: String
  created_at: timestamptz!
  creative_data: String
  creative_type: String
  id: Int!
  impression_tracking_tag: String
  landing_page_url: String
  name: String!
  size_or_format: String
  status: String
  updated_at: timestamptz!
}

# aggregated selection of "creatives"
type creatives_aggregate {
  aggregate: creatives_aggregate_fields
  nodes: [creatives!]!
}

# aggregate fields of "creatives"
type creatives_aggregate_fields {
  avg: creatives_avg_fields
  count(columns: [creatives_select_column!], distinct: Boolean): Int
  max: creatives_max_fields
  min: creatives_min_fields
  stddev: creatives_stddev_fields
  stddev_pop: creatives_stddev_pop_fields
  stddev_samp: creatives_stddev_samp_fields
  sum: creatives_sum_fields
  var_pop: creatives_var_pop_fields
  var_samp: creatives_var_samp_fields
  variance: creatives_variance_fields
}

# order by aggregate values of table "creatives"
input creatives_aggregate_order_by {
  avg: creatives_avg_order_by
  count: order_by
  max: creatives_max_order_by
  min: creatives_min_order_by
  stddev: creatives_stddev_order_by
  stddev_pop: creatives_stddev_pop_order_by
  stddev_samp: creatives_stddev_samp_order_by
  sum: creatives_sum_order_by
  var_pop: creatives_var_pop_order_by
  var_samp: creatives_var_samp_order_by
  variance: creatives_variance_order_by
}

# input type for inserting array relation for remote table "creatives"
input creatives_arr_rel_insert_input {
  data: [creatives_insert_input!]!
  on_conflict: creatives_on_conflict
}

# aggregate avg on columns
type creatives_avg_fields {
  channel_set_id: Float
  id: Float
}

# order by avg() on columns of table "creatives"
input creatives_avg_order_by {
  channel_set_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "creatives". All fields are combined with a logical 'AND'.
input creatives_bool_exp {
  _and: [creatives_bool_exp]
  _not: creatives_bool_exp
  _or: [creatives_bool_exp]
  channel_set: channel_sets_bool_exp
  channel_set_id: Int_comparison_exp
  click_tracking_tag: String_comparison_exp
  created_at: timestamptz_comparison_exp
  creative_data: String_comparison_exp
  creative_type: String_comparison_exp
  id: Int_comparison_exp
  impression_tracking_tag: String_comparison_exp
  landing_page_url: String_comparison_exp
  name: String_comparison_exp
  size_or_format: String_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "creatives"
enum creatives_constraint {
  # unique or primary key constraint
  creatives_pkey
}

# input type for incrementing integer column in table "creatives"
input creatives_inc_input {
  channel_set_id: Int
  id: Int
}

# input type for inserting data into table "creatives"
input creatives_insert_input {
  channel_set: channel_sets_obj_rel_insert_input
  channel_set_id: Int
  click_tracking_tag: String
  created_at: timestamptz
  creative_data: String
  creative_type: String
  id: Int
  impression_tracking_tag: String
  landing_page_url: String
  name: String
  size_or_format: String
  status: String
  updated_at: timestamptz
}

# aggregate max on columns
type creatives_max_fields {
  channel_set_id: Int
  click_tracking_tag: String
  created_at: timestamptz
  creative_data: String
  creative_type: String
  id: Int
  impression_tracking_tag: String
  landing_page_url: String
  name: String
  size_or_format: String
  status: String
  updated_at: timestamptz
}

# order by max() on columns of table "creatives"
input creatives_max_order_by {
  channel_set_id: order_by
  click_tracking_tag: order_by
  created_at: order_by
  creative_data: order_by
  creative_type: order_by
  id: order_by
  impression_tracking_tag: order_by
  landing_page_url: order_by
  name: order_by
  size_or_format: order_by
  status: order_by
  updated_at: order_by
}

# aggregate min on columns
type creatives_min_fields {
  channel_set_id: Int
  click_tracking_tag: String
  created_at: timestamptz
  creative_data: String
  creative_type: String
  id: Int
  impression_tracking_tag: String
  landing_page_url: String
  name: String
  size_or_format: String
  status: String
  updated_at: timestamptz
}

# order by min() on columns of table "creatives"
input creatives_min_order_by {
  channel_set_id: order_by
  click_tracking_tag: order_by
  created_at: order_by
  creative_data: order_by
  creative_type: order_by
  id: order_by
  impression_tracking_tag: order_by
  landing_page_url: order_by
  name: order_by
  size_or_format: order_by
  status: order_by
  updated_at: order_by
}

# response of any mutation on the table "creatives"
type creatives_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [creatives!]!
}

# input type for inserting object relation for remote table "creatives"
input creatives_obj_rel_insert_input {
  data: creatives_insert_input!
  on_conflict: creatives_on_conflict
}

# on conflict condition type for table "creatives"
input creatives_on_conflict {
  constraint: creatives_constraint!
  update_columns: [creatives_update_column!]!
  where: creatives_bool_exp
}

# ordering options when selecting data from "creatives"
input creatives_order_by {
  channel_set: channel_sets_order_by
  channel_set_id: order_by
  click_tracking_tag: order_by
  created_at: order_by
  creative_data: order_by
  creative_type: order_by
  id: order_by
  impression_tracking_tag: order_by
  landing_page_url: order_by
  name: order_by
  size_or_format: order_by
  status: order_by
  updated_at: order_by
}

# primary key columns input for table: "creatives"
input creatives_pk_columns_input {
  id: Int!
}

# select columns of table "creatives"
enum creatives_select_column {
  # column name
  channel_set_id

  # column name
  click_tracking_tag

  # column name
  created_at

  # column name
  creative_data

  # column name
  creative_type

  # column name
  id

  # column name
  impression_tracking_tag

  # column name
  landing_page_url

  # column name
  name

  # column name
  size_or_format

  # column name
  status

  # column name
  updated_at
}

# input type for updating data in table "creatives"
input creatives_set_input {
  channel_set_id: Int
  click_tracking_tag: String
  created_at: timestamptz
  creative_data: String
  creative_type: String
  id: Int
  impression_tracking_tag: String
  landing_page_url: String
  name: String
  size_or_format: String
  status: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type creatives_stddev_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev() on columns of table "creatives"
input creatives_stddev_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type creatives_stddev_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "creatives"
input creatives_stddev_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type creatives_stddev_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "creatives"
input creatives_stddev_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate sum on columns
type creatives_sum_fields {
  channel_set_id: Int
  id: Int
}

# order by sum() on columns of table "creatives"
input creatives_sum_order_by {
  channel_set_id: order_by
  id: order_by
}

# update columns of table "creatives"
enum creatives_update_column {
  # column name
  channel_set_id

  # column name
  click_tracking_tag

  # column name
  created_at

  # column name
  creative_data

  # column name
  creative_type

  # column name
  id

  # column name
  impression_tracking_tag

  # column name
  landing_page_url

  # column name
  name

  # column name
  size_or_format

  # column name
  status

  # column name
  updated_at
}

# aggregate var_pop on columns
type creatives_var_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by var_pop() on columns of table "creatives"
input creatives_var_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type creatives_var_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by var_samp() on columns of table "creatives"
input creatives_var_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate variance on columns
type creatives_variance_fields {
  channel_set_id: Float
  id: Float
}

# order by variance() on columns of table "creatives"
input creatives_variance_order_by {
  channel_set_id: order_by
  id: order_by
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# mutation root
type mutation_root {
  # delete data from the table: "account_channels"
  delete_account_channels(
    # filter the rows which have to be deleted
    where: account_channels_bool_exp!
  ): account_channels_mutation_response

  # delete single row from the table: "account_channels"
  delete_account_channels_by_pk(value: String!): account_channels

  # delete data from the table: "account_payment_terms"
  delete_account_payment_terms(
    # filter the rows which have to be deleted
    where: account_payment_terms_bool_exp!
  ): account_payment_terms_mutation_response

  # delete single row from the table: "account_payment_terms"
  delete_account_payment_terms_by_pk(value: String!): account_payment_terms

  # delete data from the table: "account_regions"
  delete_account_regions(
    # filter the rows which have to be deleted
    where: account_regions_bool_exp!
  ): account_regions_mutation_response

  # delete single row from the table: "account_regions"
  delete_account_regions_by_pk(value: String!): account_regions

  # delete data from the table: "account_statuses"
  delete_account_statuses(
    # filter the rows which have to be deleted
    where: account_statuses_bool_exp!
  ): account_statuses_mutation_response

  # delete single row from the table: "account_statuses"
  delete_account_statuses_by_pk(value: String!): account_statuses

  # delete data from the table: "account_tiers"
  delete_account_tiers(
    # filter the rows which have to be deleted
    where: account_tiers_bool_exp!
  ): account_tiers_mutation_response

  # delete single row from the table: "account_tiers"
  delete_account_tiers_by_pk(value: String!): account_tiers

  # delete data from the table: "account_types"
  delete_account_types(
    # filter the rows which have to be deleted
    where: account_types_bool_exp!
  ): account_types_mutation_response

  # delete single row from the table: "account_types"
  delete_account_types_by_pk(value: String!): account_types

  # delete data from the table: "account_verticals"
  delete_account_verticals(
    # filter the rows which have to be deleted
    where: account_verticals_bool_exp!
  ): account_verticals_mutation_response

  # delete single row from the table: "account_verticals"
  delete_account_verticals_by_pk(value: String!): account_verticals

  # delete data from the table: "accounts"
  delete_accounts(
    # filter the rows which have to be deleted
    where: accounts_bool_exp!
  ): accounts_mutation_response

  # delete single row from the table: "accounts"
  delete_accounts_by_pk(id: Int!): accounts

  # delete data from the table: "campaigns"
  delete_campaigns(
    # filter the rows which have to be deleted
    where: campaigns_bool_exp!
  ): campaigns_mutation_response

  # delete single row from the table: "campaigns"
  delete_campaigns_by_pk(id: Int!): campaigns

  # delete data from the table: "channel_sets"
  delete_channel_sets(
    # filter the rows which have to be deleted
    where: channel_sets_bool_exp!
  ): channel_sets_mutation_response

  # delete single row from the table: "channel_sets"
  delete_channel_sets_by_pk(id: Int!): channel_sets

  # delete data from the table: "contract_line_items"
  delete_contract_line_items(
    # filter the rows which have to be deleted
    where: contract_line_items_bool_exp!
  ): contract_line_items_mutation_response

  # delete single row from the table: "contract_line_items"
  delete_contract_line_items_by_pk(id: Int!): contract_line_items

  # delete data from the table: "contracts"
  delete_contracts(
    # filter the rows which have to be deleted
    where: contracts_bool_exp!
  ): contracts_mutation_response

  # delete single row from the table: "contracts"
  delete_contracts_by_pk(id: Int!): contracts

  # delete data from the table: "creatives"
  delete_creatives(
    # filter the rows which have to be deleted
    where: creatives_bool_exp!
  ): creatives_mutation_response

  # delete single row from the table: "creatives"
  delete_creatives_by_pk(id: Int!): creatives

  # delete data from the table: "optimization_modules"
  delete_optimization_modules(
    # filter the rows which have to be deleted
    where: optimization_modules_bool_exp!
  ): optimization_modules_mutation_response

  # delete single row from the table: "optimization_modules"
  delete_optimization_modules_by_pk(id: Int!): optimization_modules

  # delete data from the table: "setup_modules"
  delete_setup_modules(
    # filter the rows which have to be deleted
    where: setup_modules_bool_exp!
  ): setup_modules_mutation_response

  # delete single row from the table: "setup_modules"
  delete_setup_modules_by_pk(id: Int!): setup_modules

  # delete data from the table: "tactic_goal_types"
  delete_tactic_goal_types(
    # filter the rows which have to be deleted
    where: tactic_goal_types_bool_exp!
  ): tactic_goal_types_mutation_response

  # delete single row from the table: "tactic_goal_types"
  delete_tactic_goal_types_by_pk(value: String!): tactic_goal_types

  # delete data from the table: "tactic_types"
  delete_tactic_types(
    # filter the rows which have to be deleted
    where: tactic_types_bool_exp!
  ): tactic_types_mutation_response

  # delete single row from the table: "tactic_types"
  delete_tactic_types_by_pk(value: String!): tactic_types

  # delete data from the table: "tactics"
  delete_tactics(
    # filter the rows which have to be deleted
    where: tactics_bool_exp!
  ): tactics_mutation_response

  # delete single row from the table: "tactics"
  delete_tactics_by_pk(id: Int!): tactics

  # delete data from the table: "traveler_segments"
  delete_traveler_segments(
    # filter the rows which have to be deleted
    where: traveler_segments_bool_exp!
  ): traveler_segments_mutation_response

  # delete single row from the table: "traveler_segments"
  delete_traveler_segments_by_pk(id: Int!): traveler_segments

  # insert data into the table: "account_channels"
  insert_account_channels(
    # the rows to be inserted
    objects: [account_channels_insert_input!]!

    # on conflict condition
    on_conflict: account_channels_on_conflict
  ): account_channels_mutation_response

  # insert a single row into the table: "account_channels"
  insert_account_channels_one(
    # the row to be inserted
    object: account_channels_insert_input!

    # on conflict condition
    on_conflict: account_channels_on_conflict
  ): account_channels

  # insert data into the table: "account_payment_terms"
  insert_account_payment_terms(
    # the rows to be inserted
    objects: [account_payment_terms_insert_input!]!

    # on conflict condition
    on_conflict: account_payment_terms_on_conflict
  ): account_payment_terms_mutation_response

  # insert a single row into the table: "account_payment_terms"
  insert_account_payment_terms_one(
    # the row to be inserted
    object: account_payment_terms_insert_input!

    # on conflict condition
    on_conflict: account_payment_terms_on_conflict
  ): account_payment_terms

  # insert data into the table: "account_regions"
  insert_account_regions(
    # the rows to be inserted
    objects: [account_regions_insert_input!]!

    # on conflict condition
    on_conflict: account_regions_on_conflict
  ): account_regions_mutation_response

  # insert a single row into the table: "account_regions"
  insert_account_regions_one(
    # the row to be inserted
    object: account_regions_insert_input!

    # on conflict condition
    on_conflict: account_regions_on_conflict
  ): account_regions

  # insert data into the table: "account_statuses"
  insert_account_statuses(
    # the rows to be inserted
    objects: [account_statuses_insert_input!]!

    # on conflict condition
    on_conflict: account_statuses_on_conflict
  ): account_statuses_mutation_response

  # insert a single row into the table: "account_statuses"
  insert_account_statuses_one(
    # the row to be inserted
    object: account_statuses_insert_input!

    # on conflict condition
    on_conflict: account_statuses_on_conflict
  ): account_statuses

  # insert data into the table: "account_tiers"
  insert_account_tiers(
    # the rows to be inserted
    objects: [account_tiers_insert_input!]!

    # on conflict condition
    on_conflict: account_tiers_on_conflict
  ): account_tiers_mutation_response

  # insert a single row into the table: "account_tiers"
  insert_account_tiers_one(
    # the row to be inserted
    object: account_tiers_insert_input!

    # on conflict condition
    on_conflict: account_tiers_on_conflict
  ): account_tiers

  # insert data into the table: "account_types"
  insert_account_types(
    # the rows to be inserted
    objects: [account_types_insert_input!]!

    # on conflict condition
    on_conflict: account_types_on_conflict
  ): account_types_mutation_response

  # insert a single row into the table: "account_types"
  insert_account_types_one(
    # the row to be inserted
    object: account_types_insert_input!

    # on conflict condition
    on_conflict: account_types_on_conflict
  ): account_types

  # insert data into the table: "account_verticals"
  insert_account_verticals(
    # the rows to be inserted
    objects: [account_verticals_insert_input!]!

    # on conflict condition
    on_conflict: account_verticals_on_conflict
  ): account_verticals_mutation_response

  # insert a single row into the table: "account_verticals"
  insert_account_verticals_one(
    # the row to be inserted
    object: account_verticals_insert_input!

    # on conflict condition
    on_conflict: account_verticals_on_conflict
  ): account_verticals

  # insert data into the table: "accounts"
  insert_accounts(
    # the rows to be inserted
    objects: [accounts_insert_input!]!

    # on conflict condition
    on_conflict: accounts_on_conflict
  ): accounts_mutation_response

  # insert a single row into the table: "accounts"
  insert_accounts_one(
    # the row to be inserted
    object: accounts_insert_input!

    # on conflict condition
    on_conflict: accounts_on_conflict
  ): accounts

  # insert data into the table: "campaigns"
  insert_campaigns(
    # the rows to be inserted
    objects: [campaigns_insert_input!]!

    # on conflict condition
    on_conflict: campaigns_on_conflict
  ): campaigns_mutation_response

  # insert a single row into the table: "campaigns"
  insert_campaigns_one(
    # the row to be inserted
    object: campaigns_insert_input!

    # on conflict condition
    on_conflict: campaigns_on_conflict
  ): campaigns

  # insert data into the table: "channel_sets"
  insert_channel_sets(
    # the rows to be inserted
    objects: [channel_sets_insert_input!]!

    # on conflict condition
    on_conflict: channel_sets_on_conflict
  ): channel_sets_mutation_response

  # insert a single row into the table: "channel_sets"
  insert_channel_sets_one(
    # the row to be inserted
    object: channel_sets_insert_input!

    # on conflict condition
    on_conflict: channel_sets_on_conflict
  ): channel_sets

  # insert data into the table: "contract_line_items"
  insert_contract_line_items(
    # the rows to be inserted
    objects: [contract_line_items_insert_input!]!

    # on conflict condition
    on_conflict: contract_line_items_on_conflict
  ): contract_line_items_mutation_response

  # insert a single row into the table: "contract_line_items"
  insert_contract_line_items_one(
    # the row to be inserted
    object: contract_line_items_insert_input!

    # on conflict condition
    on_conflict: contract_line_items_on_conflict
  ): contract_line_items

  # insert data into the table: "contracts"
  insert_contracts(
    # the rows to be inserted
    objects: [contracts_insert_input!]!

    # on conflict condition
    on_conflict: contracts_on_conflict
  ): contracts_mutation_response

  # insert a single row into the table: "contracts"
  insert_contracts_one(
    # the row to be inserted
    object: contracts_insert_input!

    # on conflict condition
    on_conflict: contracts_on_conflict
  ): contracts

  # insert data into the table: "creatives"
  insert_creatives(
    # the rows to be inserted
    objects: [creatives_insert_input!]!

    # on conflict condition
    on_conflict: creatives_on_conflict
  ): creatives_mutation_response

  # insert a single row into the table: "creatives"
  insert_creatives_one(
    # the row to be inserted
    object: creatives_insert_input!

    # on conflict condition
    on_conflict: creatives_on_conflict
  ): creatives

  # insert data into the table: "optimization_modules"
  insert_optimization_modules(
    # the rows to be inserted
    objects: [optimization_modules_insert_input!]!

    # on conflict condition
    on_conflict: optimization_modules_on_conflict
  ): optimization_modules_mutation_response

  # insert a single row into the table: "optimization_modules"
  insert_optimization_modules_one(
    # the row to be inserted
    object: optimization_modules_insert_input!

    # on conflict condition
    on_conflict: optimization_modules_on_conflict
  ): optimization_modules

  # insert data into the table: "setup_modules"
  insert_setup_modules(
    # the rows to be inserted
    objects: [setup_modules_insert_input!]!

    # on conflict condition
    on_conflict: setup_modules_on_conflict
  ): setup_modules_mutation_response

  # insert a single row into the table: "setup_modules"
  insert_setup_modules_one(
    # the row to be inserted
    object: setup_modules_insert_input!

    # on conflict condition
    on_conflict: setup_modules_on_conflict
  ): setup_modules

  # insert data into the table: "tactic_goal_types"
  insert_tactic_goal_types(
    # the rows to be inserted
    objects: [tactic_goal_types_insert_input!]!

    # on conflict condition
    on_conflict: tactic_goal_types_on_conflict
  ): tactic_goal_types_mutation_response

  # insert a single row into the table: "tactic_goal_types"
  insert_tactic_goal_types_one(
    # the row to be inserted
    object: tactic_goal_types_insert_input!

    # on conflict condition
    on_conflict: tactic_goal_types_on_conflict
  ): tactic_goal_types

  # insert data into the table: "tactic_types"
  insert_tactic_types(
    # the rows to be inserted
    objects: [tactic_types_insert_input!]!

    # on conflict condition
    on_conflict: tactic_types_on_conflict
  ): tactic_types_mutation_response

  # insert a single row into the table: "tactic_types"
  insert_tactic_types_one(
    # the row to be inserted
    object: tactic_types_insert_input!

    # on conflict condition
    on_conflict: tactic_types_on_conflict
  ): tactic_types

  # insert data into the table: "tactics"
  insert_tactics(
    # the rows to be inserted
    objects: [tactics_insert_input!]!

    # on conflict condition
    on_conflict: tactics_on_conflict
  ): tactics_mutation_response

  # insert a single row into the table: "tactics"
  insert_tactics_one(
    # the row to be inserted
    object: tactics_insert_input!

    # on conflict condition
    on_conflict: tactics_on_conflict
  ): tactics

  # insert data into the table: "traveler_segments"
  insert_traveler_segments(
    # the rows to be inserted
    objects: [traveler_segments_insert_input!]!

    # on conflict condition
    on_conflict: traveler_segments_on_conflict
  ): traveler_segments_mutation_response

  # insert a single row into the table: "traveler_segments"
  insert_traveler_segments_one(
    # the row to be inserted
    object: traveler_segments_insert_input!

    # on conflict condition
    on_conflict: traveler_segments_on_conflict
  ): traveler_segments

  # update data of the table: "account_channels"
  update_account_channels(
    # sets the columns of the filtered rows to the given values
    _set: account_channels_set_input

    # filter the rows which have to be updated
    where: account_channels_bool_exp!
  ): account_channels_mutation_response

  # update single row of the table: "account_channels"
  update_account_channels_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: account_channels_set_input
    pk_columns: account_channels_pk_columns_input!
  ): account_channels

  # update data of the table: "account_payment_terms"
  update_account_payment_terms(
    # sets the columns of the filtered rows to the given values
    _set: account_payment_terms_set_input

    # filter the rows which have to be updated
    where: account_payment_terms_bool_exp!
  ): account_payment_terms_mutation_response

  # update single row of the table: "account_payment_terms"
  update_account_payment_terms_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: account_payment_terms_set_input
    pk_columns: account_payment_terms_pk_columns_input!
  ): account_payment_terms

  # update data of the table: "account_regions"
  update_account_regions(
    # sets the columns of the filtered rows to the given values
    _set: account_regions_set_input

    # filter the rows which have to be updated
    where: account_regions_bool_exp!
  ): account_regions_mutation_response

  # update single row of the table: "account_regions"
  update_account_regions_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: account_regions_set_input
    pk_columns: account_regions_pk_columns_input!
  ): account_regions

  # update data of the table: "account_statuses"
  update_account_statuses(
    # sets the columns of the filtered rows to the given values
    _set: account_statuses_set_input

    # filter the rows which have to be updated
    where: account_statuses_bool_exp!
  ): account_statuses_mutation_response

  # update single row of the table: "account_statuses"
  update_account_statuses_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: account_statuses_set_input
    pk_columns: account_statuses_pk_columns_input!
  ): account_statuses

  # update data of the table: "account_tiers"
  update_account_tiers(
    # sets the columns of the filtered rows to the given values
    _set: account_tiers_set_input

    # filter the rows which have to be updated
    where: account_tiers_bool_exp!
  ): account_tiers_mutation_response

  # update single row of the table: "account_tiers"
  update_account_tiers_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: account_tiers_set_input
    pk_columns: account_tiers_pk_columns_input!
  ): account_tiers

  # update data of the table: "account_types"
  update_account_types(
    # sets the columns of the filtered rows to the given values
    _set: account_types_set_input

    # filter the rows which have to be updated
    where: account_types_bool_exp!
  ): account_types_mutation_response

  # update single row of the table: "account_types"
  update_account_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: account_types_set_input
    pk_columns: account_types_pk_columns_input!
  ): account_types

  # update data of the table: "account_verticals"
  update_account_verticals(
    # sets the columns of the filtered rows to the given values
    _set: account_verticals_set_input

    # filter the rows which have to be updated
    where: account_verticals_bool_exp!
  ): account_verticals_mutation_response

  # update single row of the table: "account_verticals"
  update_account_verticals_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: account_verticals_set_input
    pk_columns: account_verticals_pk_columns_input!
  ): account_verticals

  # update data of the table: "accounts"
  update_accounts(
    # increments the integer columns with given value of the filtered values
    _inc: accounts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: accounts_set_input

    # filter the rows which have to be updated
    where: accounts_bool_exp!
  ): accounts_mutation_response

  # update single row of the table: "accounts"
  update_accounts_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: accounts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: accounts_set_input
    pk_columns: accounts_pk_columns_input!
  ): accounts

  # update data of the table: "campaigns"
  update_campaigns(
    # increments the integer columns with given value of the filtered values
    _inc: campaigns_inc_input

    # sets the columns of the filtered rows to the given values
    _set: campaigns_set_input

    # filter the rows which have to be updated
    where: campaigns_bool_exp!
  ): campaigns_mutation_response

  # update single row of the table: "campaigns"
  update_campaigns_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: campaigns_inc_input

    # sets the columns of the filtered rows to the given values
    _set: campaigns_set_input
    pk_columns: campaigns_pk_columns_input!
  ): campaigns

  # update data of the table: "channel_sets"
  update_channel_sets(
    # increments the integer columns with given value of the filtered values
    _inc: channel_sets_inc_input

    # sets the columns of the filtered rows to the given values
    _set: channel_sets_set_input

    # filter the rows which have to be updated
    where: channel_sets_bool_exp!
  ): channel_sets_mutation_response

  # update single row of the table: "channel_sets"
  update_channel_sets_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: channel_sets_inc_input

    # sets the columns of the filtered rows to the given values
    _set: channel_sets_set_input
    pk_columns: channel_sets_pk_columns_input!
  ): channel_sets

  # update data of the table: "contract_line_items"
  update_contract_line_items(
    # increments the integer columns with given value of the filtered values
    _inc: contract_line_items_inc_input

    # sets the columns of the filtered rows to the given values
    _set: contract_line_items_set_input

    # filter the rows which have to be updated
    where: contract_line_items_bool_exp!
  ): contract_line_items_mutation_response

  # update single row of the table: "contract_line_items"
  update_contract_line_items_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: contract_line_items_inc_input

    # sets the columns of the filtered rows to the given values
    _set: contract_line_items_set_input
    pk_columns: contract_line_items_pk_columns_input!
  ): contract_line_items

  # update data of the table: "contracts"
  update_contracts(
    # increments the integer columns with given value of the filtered values
    _inc: contracts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: contracts_set_input

    # filter the rows which have to be updated
    where: contracts_bool_exp!
  ): contracts_mutation_response

  # update single row of the table: "contracts"
  update_contracts_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: contracts_inc_input

    # sets the columns of the filtered rows to the given values
    _set: contracts_set_input
    pk_columns: contracts_pk_columns_input!
  ): contracts

  # update data of the table: "creatives"
  update_creatives(
    # increments the integer columns with given value of the filtered values
    _inc: creatives_inc_input

    # sets the columns of the filtered rows to the given values
    _set: creatives_set_input

    # filter the rows which have to be updated
    where: creatives_bool_exp!
  ): creatives_mutation_response

  # update single row of the table: "creatives"
  update_creatives_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: creatives_inc_input

    # sets the columns of the filtered rows to the given values
    _set: creatives_set_input
    pk_columns: creatives_pk_columns_input!
  ): creatives

  # update data of the table: "optimization_modules"
  update_optimization_modules(
    # increments the integer columns with given value of the filtered values
    _inc: optimization_modules_inc_input

    # sets the columns of the filtered rows to the given values
    _set: optimization_modules_set_input

    # filter the rows which have to be updated
    where: optimization_modules_bool_exp!
  ): optimization_modules_mutation_response

  # update single row of the table: "optimization_modules"
  update_optimization_modules_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: optimization_modules_inc_input

    # sets the columns of the filtered rows to the given values
    _set: optimization_modules_set_input
    pk_columns: optimization_modules_pk_columns_input!
  ): optimization_modules

  # update data of the table: "setup_modules"
  update_setup_modules(
    # increments the integer columns with given value of the filtered values
    _inc: setup_modules_inc_input

    # sets the columns of the filtered rows to the given values
    _set: setup_modules_set_input

    # filter the rows which have to be updated
    where: setup_modules_bool_exp!
  ): setup_modules_mutation_response

  # update single row of the table: "setup_modules"
  update_setup_modules_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: setup_modules_inc_input

    # sets the columns of the filtered rows to the given values
    _set: setup_modules_set_input
    pk_columns: setup_modules_pk_columns_input!
  ): setup_modules

  # update data of the table: "tactic_goal_types"
  update_tactic_goal_types(
    # sets the columns of the filtered rows to the given values
    _set: tactic_goal_types_set_input

    # filter the rows which have to be updated
    where: tactic_goal_types_bool_exp!
  ): tactic_goal_types_mutation_response

  # update single row of the table: "tactic_goal_types"
  update_tactic_goal_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: tactic_goal_types_set_input
    pk_columns: tactic_goal_types_pk_columns_input!
  ): tactic_goal_types

  # update data of the table: "tactic_types"
  update_tactic_types(
    # sets the columns of the filtered rows to the given values
    _set: tactic_types_set_input

    # filter the rows which have to be updated
    where: tactic_types_bool_exp!
  ): tactic_types_mutation_response

  # update single row of the table: "tactic_types"
  update_tactic_types_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: tactic_types_set_input
    pk_columns: tactic_types_pk_columns_input!
  ): tactic_types

  # update data of the table: "tactics"
  update_tactics(
    # increments the integer columns with given value of the filtered values
    _inc: tactics_inc_input

    # sets the columns of the filtered rows to the given values
    _set: tactics_set_input

    # filter the rows which have to be updated
    where: tactics_bool_exp!
  ): tactics_mutation_response

  # update single row of the table: "tactics"
  update_tactics_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: tactics_inc_input

    # sets the columns of the filtered rows to the given values
    _set: tactics_set_input
    pk_columns: tactics_pk_columns_input!
  ): tactics

  # update data of the table: "traveler_segments"
  update_traveler_segments(
    # increments the integer columns with given value of the filtered values
    _inc: traveler_segments_inc_input

    # sets the columns of the filtered rows to the given values
    _set: traveler_segments_set_input

    # filter the rows which have to be updated
    where: traveler_segments_bool_exp!
  ): traveler_segments_mutation_response

  # update single row of the table: "traveler_segments"
  update_traveler_segments_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: traveler_segments_inc_input

    # sets the columns of the filtered rows to the given values
    _set: traveler_segments_set_input
    pk_columns: traveler_segments_pk_columns_input!
  ): traveler_segments
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# columns and relationships of "optimization_modules"
type optimization_modules {
  # An object relationship
  channel_set: channel_sets
  channel_set_id: Int
  created_at: timestamptz!
  id: Int!
  name: String
  updated_at: timestamptz!
}

# aggregated selection of "optimization_modules"
type optimization_modules_aggregate {
  aggregate: optimization_modules_aggregate_fields
  nodes: [optimization_modules!]!
}

# aggregate fields of "optimization_modules"
type optimization_modules_aggregate_fields {
  avg: optimization_modules_avg_fields
  count(columns: [optimization_modules_select_column!], distinct: Boolean): Int
  max: optimization_modules_max_fields
  min: optimization_modules_min_fields
  stddev: optimization_modules_stddev_fields
  stddev_pop: optimization_modules_stddev_pop_fields
  stddev_samp: optimization_modules_stddev_samp_fields
  sum: optimization_modules_sum_fields
  var_pop: optimization_modules_var_pop_fields
  var_samp: optimization_modules_var_samp_fields
  variance: optimization_modules_variance_fields
}

# order by aggregate values of table "optimization_modules"
input optimization_modules_aggregate_order_by {
  avg: optimization_modules_avg_order_by
  count: order_by
  max: optimization_modules_max_order_by
  min: optimization_modules_min_order_by
  stddev: optimization_modules_stddev_order_by
  stddev_pop: optimization_modules_stddev_pop_order_by
  stddev_samp: optimization_modules_stddev_samp_order_by
  sum: optimization_modules_sum_order_by
  var_pop: optimization_modules_var_pop_order_by
  var_samp: optimization_modules_var_samp_order_by
  variance: optimization_modules_variance_order_by
}

# input type for inserting array relation for remote table "optimization_modules"
input optimization_modules_arr_rel_insert_input {
  data: [optimization_modules_insert_input!]!
  on_conflict: optimization_modules_on_conflict
}

# aggregate avg on columns
type optimization_modules_avg_fields {
  channel_set_id: Float
  id: Float
}

# order by avg() on columns of table "optimization_modules"
input optimization_modules_avg_order_by {
  channel_set_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "optimization_modules". All fields are combined with a logical 'AND'.
input optimization_modules_bool_exp {
  _and: [optimization_modules_bool_exp]
  _not: optimization_modules_bool_exp
  _or: [optimization_modules_bool_exp]
  channel_set: channel_sets_bool_exp
  channel_set_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "optimization_modules"
enum optimization_modules_constraint {
  # unique or primary key constraint
  optimization_modules_pkey
}

# input type for incrementing integer column in table "optimization_modules"
input optimization_modules_inc_input {
  channel_set_id: Int
  id: Int
}

# input type for inserting data into table "optimization_modules"
input optimization_modules_insert_input {
  channel_set: channel_sets_obj_rel_insert_input
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

# aggregate max on columns
type optimization_modules_max_fields {
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

# order by max() on columns of table "optimization_modules"
input optimization_modules_max_order_by {
  channel_set_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# aggregate min on columns
type optimization_modules_min_fields {
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

# order by min() on columns of table "optimization_modules"
input optimization_modules_min_order_by {
  channel_set_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# response of any mutation on the table "optimization_modules"
type optimization_modules_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [optimization_modules!]!
}

# input type for inserting object relation for remote table "optimization_modules"
input optimization_modules_obj_rel_insert_input {
  data: optimization_modules_insert_input!
  on_conflict: optimization_modules_on_conflict
}

# on conflict condition type for table "optimization_modules"
input optimization_modules_on_conflict {
  constraint: optimization_modules_constraint!
  update_columns: [optimization_modules_update_column!]!
  where: optimization_modules_bool_exp
}

# ordering options when selecting data from "optimization_modules"
input optimization_modules_order_by {
  channel_set: channel_sets_order_by
  channel_set_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  updated_at: order_by
}

# primary key columns input for table: "optimization_modules"
input optimization_modules_pk_columns_input {
  id: Int!
}

# select columns of table "optimization_modules"
enum optimization_modules_select_column {
  # column name
  channel_set_id

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# input type for updating data in table "optimization_modules"
input optimization_modules_set_input {
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type optimization_modules_stddev_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev() on columns of table "optimization_modules"
input optimization_modules_stddev_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type optimization_modules_stddev_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "optimization_modules"
input optimization_modules_stddev_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type optimization_modules_stddev_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "optimization_modules"
input optimization_modules_stddev_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate sum on columns
type optimization_modules_sum_fields {
  channel_set_id: Int
  id: Int
}

# order by sum() on columns of table "optimization_modules"
input optimization_modules_sum_order_by {
  channel_set_id: order_by
  id: order_by
}

# update columns of table "optimization_modules"
enum optimization_modules_update_column {
  # column name
  channel_set_id

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  updated_at
}

# aggregate var_pop on columns
type optimization_modules_var_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by var_pop() on columns of table "optimization_modules"
input optimization_modules_var_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type optimization_modules_var_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by var_samp() on columns of table "optimization_modules"
input optimization_modules_var_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate variance on columns
type optimization_modules_variance_fields {
  channel_set_id: Float
  id: Float
}

# order by variance() on columns of table "optimization_modules"
input optimization_modules_variance_order_by {
  channel_set_id: order_by
  id: order_by
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# query root
type query_root {
  # fetch data from the table: "account_channels"
  account_channels(
    # distinct select on columns
    distinct_on: [account_channels_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_channels_order_by!]

    # filter the rows returned
    where: account_channels_bool_exp
  ): [account_channels!]!

  # fetch aggregated fields from the table: "account_channels"
  account_channels_aggregate(
    # distinct select on columns
    distinct_on: [account_channels_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_channels_order_by!]

    # filter the rows returned
    where: account_channels_bool_exp
  ): account_channels_aggregate!

  # fetch data from the table: "account_channels" using primary key columns
  account_channels_by_pk(value: String!): account_channels

  # fetch data from the table: "account_payment_terms"
  account_payment_terms(
    # distinct select on columns
    distinct_on: [account_payment_terms_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_payment_terms_order_by!]

    # filter the rows returned
    where: account_payment_terms_bool_exp
  ): [account_payment_terms!]!

  # fetch aggregated fields from the table: "account_payment_terms"
  account_payment_terms_aggregate(
    # distinct select on columns
    distinct_on: [account_payment_terms_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_payment_terms_order_by!]

    # filter the rows returned
    where: account_payment_terms_bool_exp
  ): account_payment_terms_aggregate!

  # fetch data from the table: "account_payment_terms" using primary key columns
  account_payment_terms_by_pk(value: String!): account_payment_terms

  # fetch data from the table: "account_regions"
  account_regions(
    # distinct select on columns
    distinct_on: [account_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_regions_order_by!]

    # filter the rows returned
    where: account_regions_bool_exp
  ): [account_regions!]!

  # fetch aggregated fields from the table: "account_regions"
  account_regions_aggregate(
    # distinct select on columns
    distinct_on: [account_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_regions_order_by!]

    # filter the rows returned
    where: account_regions_bool_exp
  ): account_regions_aggregate!

  # fetch data from the table: "account_regions" using primary key columns
  account_regions_by_pk(value: String!): account_regions

  # fetch data from the table: "account_statuses"
  account_statuses(
    # distinct select on columns
    distinct_on: [account_statuses_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_statuses_order_by!]

    # filter the rows returned
    where: account_statuses_bool_exp
  ): [account_statuses!]!

  # fetch aggregated fields from the table: "account_statuses"
  account_statuses_aggregate(
    # distinct select on columns
    distinct_on: [account_statuses_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_statuses_order_by!]

    # filter the rows returned
    where: account_statuses_bool_exp
  ): account_statuses_aggregate!

  # fetch data from the table: "account_statuses" using primary key columns
  account_statuses_by_pk(value: String!): account_statuses

  # fetch data from the table: "account_tiers"
  account_tiers(
    # distinct select on columns
    distinct_on: [account_tiers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_tiers_order_by!]

    # filter the rows returned
    where: account_tiers_bool_exp
  ): [account_tiers!]!

  # fetch aggregated fields from the table: "account_tiers"
  account_tiers_aggregate(
    # distinct select on columns
    distinct_on: [account_tiers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_tiers_order_by!]

    # filter the rows returned
    where: account_tiers_bool_exp
  ): account_tiers_aggregate!

  # fetch data from the table: "account_tiers" using primary key columns
  account_tiers_by_pk(value: String!): account_tiers

  # fetch data from the table: "account_types"
  account_types(
    # distinct select on columns
    distinct_on: [account_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_types_order_by!]

    # filter the rows returned
    where: account_types_bool_exp
  ): [account_types!]!

  # fetch aggregated fields from the table: "account_types"
  account_types_aggregate(
    # distinct select on columns
    distinct_on: [account_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_types_order_by!]

    # filter the rows returned
    where: account_types_bool_exp
  ): account_types_aggregate!

  # fetch data from the table: "account_types" using primary key columns
  account_types_by_pk(value: String!): account_types

  # fetch data from the table: "account_verticals"
  account_verticals(
    # distinct select on columns
    distinct_on: [account_verticals_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_verticals_order_by!]

    # filter the rows returned
    where: account_verticals_bool_exp
  ): [account_verticals!]!

  # fetch aggregated fields from the table: "account_verticals"
  account_verticals_aggregate(
    # distinct select on columns
    distinct_on: [account_verticals_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_verticals_order_by!]

    # filter the rows returned
    where: account_verticals_bool_exp
  ): account_verticals_aggregate!

  # fetch data from the table: "account_verticals" using primary key columns
  account_verticals_by_pk(value: String!): account_verticals

  # fetch data from the table: "accounts"
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # fetch aggregated fields from the table: "accounts"
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!

  # fetch data from the table: "accounts" using primary key columns
  accounts_by_pk(id: Int!): accounts

  # fetch data from the table: "campaigns"
  campaigns(
    # distinct select on columns
    distinct_on: [campaigns_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaigns_order_by!]

    # filter the rows returned
    where: campaigns_bool_exp
  ): [campaigns!]!

  # fetch aggregated fields from the table: "campaigns"
  campaigns_aggregate(
    # distinct select on columns
    distinct_on: [campaigns_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaigns_order_by!]

    # filter the rows returned
    where: campaigns_bool_exp
  ): campaigns_aggregate!

  # fetch data from the table: "campaigns" using primary key columns
  campaigns_by_pk(id: Int!): campaigns

  # fetch data from the table: "channel_sets"
  channel_sets(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): [channel_sets!]!

  # fetch aggregated fields from the table: "channel_sets"
  channel_sets_aggregate(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): channel_sets_aggregate!

  # fetch data from the table: "channel_sets" using primary key columns
  channel_sets_by_pk(id: Int!): channel_sets

  # fetch data from the table: "contract_line_items"
  contract_line_items(
    # distinct select on columns
    distinct_on: [contract_line_items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contract_line_items_order_by!]

    # filter the rows returned
    where: contract_line_items_bool_exp
  ): [contract_line_items!]!

  # fetch aggregated fields from the table: "contract_line_items"
  contract_line_items_aggregate(
    # distinct select on columns
    distinct_on: [contract_line_items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contract_line_items_order_by!]

    # filter the rows returned
    where: contract_line_items_bool_exp
  ): contract_line_items_aggregate!

  # fetch data from the table: "contract_line_items" using primary key columns
  contract_line_items_by_pk(id: Int!): contract_line_items

  # fetch data from the table: "contracts"
  contracts(
    # distinct select on columns
    distinct_on: [contracts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contracts_order_by!]

    # filter the rows returned
    where: contracts_bool_exp
  ): [contracts!]!

  # fetch aggregated fields from the table: "contracts"
  contracts_aggregate(
    # distinct select on columns
    distinct_on: [contracts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contracts_order_by!]

    # filter the rows returned
    where: contracts_bool_exp
  ): contracts_aggregate!

  # fetch data from the table: "contracts" using primary key columns
  contracts_by_pk(id: Int!): contracts

  # fetch data from the table: "creatives"
  creatives(
    # distinct select on columns
    distinct_on: [creatives_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [creatives_order_by!]

    # filter the rows returned
    where: creatives_bool_exp
  ): [creatives!]!

  # fetch aggregated fields from the table: "creatives"
  creatives_aggregate(
    # distinct select on columns
    distinct_on: [creatives_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [creatives_order_by!]

    # filter the rows returned
    where: creatives_bool_exp
  ): creatives_aggregate!

  # fetch data from the table: "creatives" using primary key columns
  creatives_by_pk(id: Int!): creatives

  # fetch data from the table: "optimization_modules"
  optimization_modules(
    # distinct select on columns
    distinct_on: [optimization_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [optimization_modules_order_by!]

    # filter the rows returned
    where: optimization_modules_bool_exp
  ): [optimization_modules!]!

  # fetch aggregated fields from the table: "optimization_modules"
  optimization_modules_aggregate(
    # distinct select on columns
    distinct_on: [optimization_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [optimization_modules_order_by!]

    # filter the rows returned
    where: optimization_modules_bool_exp
  ): optimization_modules_aggregate!

  # fetch data from the table: "optimization_modules" using primary key columns
  optimization_modules_by_pk(id: Int!): optimization_modules

  # fetch data from the table: "setup_modules"
  setup_modules(
    # distinct select on columns
    distinct_on: [setup_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [setup_modules_order_by!]

    # filter the rows returned
    where: setup_modules_bool_exp
  ): [setup_modules!]!

  # fetch aggregated fields from the table: "setup_modules"
  setup_modules_aggregate(
    # distinct select on columns
    distinct_on: [setup_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [setup_modules_order_by!]

    # filter the rows returned
    where: setup_modules_bool_exp
  ): setup_modules_aggregate!

  # fetch data from the table: "setup_modules" using primary key columns
  setup_modules_by_pk(id: Int!): setup_modules

  # fetch data from the table: "tactic_goal_types"
  tactic_goal_types(
    # distinct select on columns
    distinct_on: [tactic_goal_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_goal_types_order_by!]

    # filter the rows returned
    where: tactic_goal_types_bool_exp
  ): [tactic_goal_types!]!

  # fetch aggregated fields from the table: "tactic_goal_types"
  tactic_goal_types_aggregate(
    # distinct select on columns
    distinct_on: [tactic_goal_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_goal_types_order_by!]

    # filter the rows returned
    where: tactic_goal_types_bool_exp
  ): tactic_goal_types_aggregate!

  # fetch data from the table: "tactic_goal_types" using primary key columns
  tactic_goal_types_by_pk(value: String!): tactic_goal_types

  # fetch data from the table: "tactic_types"
  tactic_types(
    # distinct select on columns
    distinct_on: [tactic_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_types_order_by!]

    # filter the rows returned
    where: tactic_types_bool_exp
  ): [tactic_types!]!

  # fetch aggregated fields from the table: "tactic_types"
  tactic_types_aggregate(
    # distinct select on columns
    distinct_on: [tactic_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_types_order_by!]

    # filter the rows returned
    where: tactic_types_bool_exp
  ): tactic_types_aggregate!

  # fetch data from the table: "tactic_types" using primary key columns
  tactic_types_by_pk(value: String!): tactic_types

  # fetch data from the table: "tactics"
  tactics(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): [tactics!]!

  # fetch aggregated fields from the table: "tactics"
  tactics_aggregate(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): tactics_aggregate!

  # fetch data from the table: "tactics" using primary key columns
  tactics_by_pk(id: Int!): tactics

  # fetch data from the table: "traveler_segments"
  traveler_segments(
    # distinct select on columns
    distinct_on: [traveler_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [traveler_segments_order_by!]

    # filter the rows returned
    where: traveler_segments_bool_exp
  ): [traveler_segments!]!

  # fetch aggregated fields from the table: "traveler_segments"
  traveler_segments_aggregate(
    # distinct select on columns
    distinct_on: [traveler_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [traveler_segments_order_by!]

    # filter the rows returned
    where: traveler_segments_bool_exp
  ): traveler_segments_aggregate!

  # fetch data from the table: "traveler_segments" using primary key columns
  traveler_segments_by_pk(id: Int!): traveler_segments
}

# columns and relationships of "setup_modules"
type setup_modules {
  # An object relationship
  channel_set: channel_sets
  channel_set_id: Int
  created_at: timestamptz!
  id: Int!
  name: String
  setup_rules_and_logic: String
  status: String
  supply_partner: String
  updated_at: timestamptz!
}

# aggregated selection of "setup_modules"
type setup_modules_aggregate {
  aggregate: setup_modules_aggregate_fields
  nodes: [setup_modules!]!
}

# aggregate fields of "setup_modules"
type setup_modules_aggregate_fields {
  avg: setup_modules_avg_fields
  count(columns: [setup_modules_select_column!], distinct: Boolean): Int
  max: setup_modules_max_fields
  min: setup_modules_min_fields
  stddev: setup_modules_stddev_fields
  stddev_pop: setup_modules_stddev_pop_fields
  stddev_samp: setup_modules_stddev_samp_fields
  sum: setup_modules_sum_fields
  var_pop: setup_modules_var_pop_fields
  var_samp: setup_modules_var_samp_fields
  variance: setup_modules_variance_fields
}

# order by aggregate values of table "setup_modules"
input setup_modules_aggregate_order_by {
  avg: setup_modules_avg_order_by
  count: order_by
  max: setup_modules_max_order_by
  min: setup_modules_min_order_by
  stddev: setup_modules_stddev_order_by
  stddev_pop: setup_modules_stddev_pop_order_by
  stddev_samp: setup_modules_stddev_samp_order_by
  sum: setup_modules_sum_order_by
  var_pop: setup_modules_var_pop_order_by
  var_samp: setup_modules_var_samp_order_by
  variance: setup_modules_variance_order_by
}

# input type for inserting array relation for remote table "setup_modules"
input setup_modules_arr_rel_insert_input {
  data: [setup_modules_insert_input!]!
  on_conflict: setup_modules_on_conflict
}

# aggregate avg on columns
type setup_modules_avg_fields {
  channel_set_id: Float
  id: Float
}

# order by avg() on columns of table "setup_modules"
input setup_modules_avg_order_by {
  channel_set_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "setup_modules". All fields are combined with a logical 'AND'.
input setup_modules_bool_exp {
  _and: [setup_modules_bool_exp]
  _not: setup_modules_bool_exp
  _or: [setup_modules_bool_exp]
  channel_set: channel_sets_bool_exp
  channel_set_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  setup_rules_and_logic: String_comparison_exp
  status: String_comparison_exp
  supply_partner: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "setup_modules"
enum setup_modules_constraint {
  # unique or primary key constraint
  setup_modules_pkey
}

# input type for incrementing integer column in table "setup_modules"
input setup_modules_inc_input {
  channel_set_id: Int
  id: Int
}

# input type for inserting data into table "setup_modules"
input setup_modules_insert_input {
  channel_set: channel_sets_obj_rel_insert_input
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  setup_rules_and_logic: String
  status: String
  supply_partner: String
  updated_at: timestamptz
}

# aggregate max on columns
type setup_modules_max_fields {
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  setup_rules_and_logic: String
  status: String
  supply_partner: String
  updated_at: timestamptz
}

# order by max() on columns of table "setup_modules"
input setup_modules_max_order_by {
  channel_set_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  setup_rules_and_logic: order_by
  status: order_by
  supply_partner: order_by
  updated_at: order_by
}

# aggregate min on columns
type setup_modules_min_fields {
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  setup_rules_and_logic: String
  status: String
  supply_partner: String
  updated_at: timestamptz
}

# order by min() on columns of table "setup_modules"
input setup_modules_min_order_by {
  channel_set_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  setup_rules_and_logic: order_by
  status: order_by
  supply_partner: order_by
  updated_at: order_by
}

# response of any mutation on the table "setup_modules"
type setup_modules_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [setup_modules!]!
}

# input type for inserting object relation for remote table "setup_modules"
input setup_modules_obj_rel_insert_input {
  data: setup_modules_insert_input!
  on_conflict: setup_modules_on_conflict
}

# on conflict condition type for table "setup_modules"
input setup_modules_on_conflict {
  constraint: setup_modules_constraint!
  update_columns: [setup_modules_update_column!]!
  where: setup_modules_bool_exp
}

# ordering options when selecting data from "setup_modules"
input setup_modules_order_by {
  channel_set: channel_sets_order_by
  channel_set_id: order_by
  created_at: order_by
  id: order_by
  name: order_by
  setup_rules_and_logic: order_by
  status: order_by
  supply_partner: order_by
  updated_at: order_by
}

# primary key columns input for table: "setup_modules"
input setup_modules_pk_columns_input {
  id: Int!
}

# select columns of table "setup_modules"
enum setup_modules_select_column {
  # column name
  channel_set_id

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  setup_rules_and_logic

  # column name
  status

  # column name
  supply_partner

  # column name
  updated_at
}

# input type for updating data in table "setup_modules"
input setup_modules_set_input {
  channel_set_id: Int
  created_at: timestamptz
  id: Int
  name: String
  setup_rules_and_logic: String
  status: String
  supply_partner: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type setup_modules_stddev_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev() on columns of table "setup_modules"
input setup_modules_stddev_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type setup_modules_stddev_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "setup_modules"
input setup_modules_stddev_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type setup_modules_stddev_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "setup_modules"
input setup_modules_stddev_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate sum on columns
type setup_modules_sum_fields {
  channel_set_id: Int
  id: Int
}

# order by sum() on columns of table "setup_modules"
input setup_modules_sum_order_by {
  channel_set_id: order_by
  id: order_by
}

# update columns of table "setup_modules"
enum setup_modules_update_column {
  # column name
  channel_set_id

  # column name
  created_at

  # column name
  id

  # column name
  name

  # column name
  setup_rules_and_logic

  # column name
  status

  # column name
  supply_partner

  # column name
  updated_at
}

# aggregate var_pop on columns
type setup_modules_var_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by var_pop() on columns of table "setup_modules"
input setup_modules_var_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type setup_modules_var_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by var_samp() on columns of table "setup_modules"
input setup_modules_var_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate variance on columns
type setup_modules_variance_fields {
  channel_set_id: Float
  id: Float
}

# order by variance() on columns of table "setup_modules"
input setup_modules_variance_order_by {
  channel_set_id: order_by
  id: order_by
}

scalar smallint

# expression to compare columns of type smallint. All fields are combined with logical 'AND'.
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "account_channels"
  account_channels(
    # distinct select on columns
    distinct_on: [account_channels_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_channels_order_by!]

    # filter the rows returned
    where: account_channels_bool_exp
  ): [account_channels!]!

  # fetch aggregated fields from the table: "account_channels"
  account_channels_aggregate(
    # distinct select on columns
    distinct_on: [account_channels_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_channels_order_by!]

    # filter the rows returned
    where: account_channels_bool_exp
  ): account_channels_aggregate!

  # fetch data from the table: "account_channels" using primary key columns
  account_channels_by_pk(value: String!): account_channels

  # fetch data from the table: "account_payment_terms"
  account_payment_terms(
    # distinct select on columns
    distinct_on: [account_payment_terms_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_payment_terms_order_by!]

    # filter the rows returned
    where: account_payment_terms_bool_exp
  ): [account_payment_terms!]!

  # fetch aggregated fields from the table: "account_payment_terms"
  account_payment_terms_aggregate(
    # distinct select on columns
    distinct_on: [account_payment_terms_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_payment_terms_order_by!]

    # filter the rows returned
    where: account_payment_terms_bool_exp
  ): account_payment_terms_aggregate!

  # fetch data from the table: "account_payment_terms" using primary key columns
  account_payment_terms_by_pk(value: String!): account_payment_terms

  # fetch data from the table: "account_regions"
  account_regions(
    # distinct select on columns
    distinct_on: [account_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_regions_order_by!]

    # filter the rows returned
    where: account_regions_bool_exp
  ): [account_regions!]!

  # fetch aggregated fields from the table: "account_regions"
  account_regions_aggregate(
    # distinct select on columns
    distinct_on: [account_regions_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_regions_order_by!]

    # filter the rows returned
    where: account_regions_bool_exp
  ): account_regions_aggregate!

  # fetch data from the table: "account_regions" using primary key columns
  account_regions_by_pk(value: String!): account_regions

  # fetch data from the table: "account_statuses"
  account_statuses(
    # distinct select on columns
    distinct_on: [account_statuses_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_statuses_order_by!]

    # filter the rows returned
    where: account_statuses_bool_exp
  ): [account_statuses!]!

  # fetch aggregated fields from the table: "account_statuses"
  account_statuses_aggregate(
    # distinct select on columns
    distinct_on: [account_statuses_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_statuses_order_by!]

    # filter the rows returned
    where: account_statuses_bool_exp
  ): account_statuses_aggregate!

  # fetch data from the table: "account_statuses" using primary key columns
  account_statuses_by_pk(value: String!): account_statuses

  # fetch data from the table: "account_tiers"
  account_tiers(
    # distinct select on columns
    distinct_on: [account_tiers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_tiers_order_by!]

    # filter the rows returned
    where: account_tiers_bool_exp
  ): [account_tiers!]!

  # fetch aggregated fields from the table: "account_tiers"
  account_tiers_aggregate(
    # distinct select on columns
    distinct_on: [account_tiers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_tiers_order_by!]

    # filter the rows returned
    where: account_tiers_bool_exp
  ): account_tiers_aggregate!

  # fetch data from the table: "account_tiers" using primary key columns
  account_tiers_by_pk(value: String!): account_tiers

  # fetch data from the table: "account_types"
  account_types(
    # distinct select on columns
    distinct_on: [account_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_types_order_by!]

    # filter the rows returned
    where: account_types_bool_exp
  ): [account_types!]!

  # fetch aggregated fields from the table: "account_types"
  account_types_aggregate(
    # distinct select on columns
    distinct_on: [account_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_types_order_by!]

    # filter the rows returned
    where: account_types_bool_exp
  ): account_types_aggregate!

  # fetch data from the table: "account_types" using primary key columns
  account_types_by_pk(value: String!): account_types

  # fetch data from the table: "account_verticals"
  account_verticals(
    # distinct select on columns
    distinct_on: [account_verticals_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_verticals_order_by!]

    # filter the rows returned
    where: account_verticals_bool_exp
  ): [account_verticals!]!

  # fetch aggregated fields from the table: "account_verticals"
  account_verticals_aggregate(
    # distinct select on columns
    distinct_on: [account_verticals_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_verticals_order_by!]

    # filter the rows returned
    where: account_verticals_bool_exp
  ): account_verticals_aggregate!

  # fetch data from the table: "account_verticals" using primary key columns
  account_verticals_by_pk(value: String!): account_verticals

  # fetch data from the table: "accounts"
  accounts(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): [accounts!]!

  # fetch aggregated fields from the table: "accounts"
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [accounts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [accounts_order_by!]

    # filter the rows returned
    where: accounts_bool_exp
  ): accounts_aggregate!

  # fetch data from the table: "accounts" using primary key columns
  accounts_by_pk(id: Int!): accounts

  # fetch data from the table: "campaigns"
  campaigns(
    # distinct select on columns
    distinct_on: [campaigns_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaigns_order_by!]

    # filter the rows returned
    where: campaigns_bool_exp
  ): [campaigns!]!

  # fetch aggregated fields from the table: "campaigns"
  campaigns_aggregate(
    # distinct select on columns
    distinct_on: [campaigns_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaigns_order_by!]

    # filter the rows returned
    where: campaigns_bool_exp
  ): campaigns_aggregate!

  # fetch data from the table: "campaigns" using primary key columns
  campaigns_by_pk(id: Int!): campaigns

  # fetch data from the table: "channel_sets"
  channel_sets(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): [channel_sets!]!

  # fetch aggregated fields from the table: "channel_sets"
  channel_sets_aggregate(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): channel_sets_aggregate!

  # fetch data from the table: "channel_sets" using primary key columns
  channel_sets_by_pk(id: Int!): channel_sets

  # fetch data from the table: "contract_line_items"
  contract_line_items(
    # distinct select on columns
    distinct_on: [contract_line_items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contract_line_items_order_by!]

    # filter the rows returned
    where: contract_line_items_bool_exp
  ): [contract_line_items!]!

  # fetch aggregated fields from the table: "contract_line_items"
  contract_line_items_aggregate(
    # distinct select on columns
    distinct_on: [contract_line_items_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contract_line_items_order_by!]

    # filter the rows returned
    where: contract_line_items_bool_exp
  ): contract_line_items_aggregate!

  # fetch data from the table: "contract_line_items" using primary key columns
  contract_line_items_by_pk(id: Int!): contract_line_items

  # fetch data from the table: "contracts"
  contracts(
    # distinct select on columns
    distinct_on: [contracts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contracts_order_by!]

    # filter the rows returned
    where: contracts_bool_exp
  ): [contracts!]!

  # fetch aggregated fields from the table: "contracts"
  contracts_aggregate(
    # distinct select on columns
    distinct_on: [contracts_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [contracts_order_by!]

    # filter the rows returned
    where: contracts_bool_exp
  ): contracts_aggregate!

  # fetch data from the table: "contracts" using primary key columns
  contracts_by_pk(id: Int!): contracts

  # fetch data from the table: "creatives"
  creatives(
    # distinct select on columns
    distinct_on: [creatives_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [creatives_order_by!]

    # filter the rows returned
    where: creatives_bool_exp
  ): [creatives!]!

  # fetch aggregated fields from the table: "creatives"
  creatives_aggregate(
    # distinct select on columns
    distinct_on: [creatives_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [creatives_order_by!]

    # filter the rows returned
    where: creatives_bool_exp
  ): creatives_aggregate!

  # fetch data from the table: "creatives" using primary key columns
  creatives_by_pk(id: Int!): creatives

  # fetch data from the table: "optimization_modules"
  optimization_modules(
    # distinct select on columns
    distinct_on: [optimization_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [optimization_modules_order_by!]

    # filter the rows returned
    where: optimization_modules_bool_exp
  ): [optimization_modules!]!

  # fetch aggregated fields from the table: "optimization_modules"
  optimization_modules_aggregate(
    # distinct select on columns
    distinct_on: [optimization_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [optimization_modules_order_by!]

    # filter the rows returned
    where: optimization_modules_bool_exp
  ): optimization_modules_aggregate!

  # fetch data from the table: "optimization_modules" using primary key columns
  optimization_modules_by_pk(id: Int!): optimization_modules

  # fetch data from the table: "setup_modules"
  setup_modules(
    # distinct select on columns
    distinct_on: [setup_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [setup_modules_order_by!]

    # filter the rows returned
    where: setup_modules_bool_exp
  ): [setup_modules!]!

  # fetch aggregated fields from the table: "setup_modules"
  setup_modules_aggregate(
    # distinct select on columns
    distinct_on: [setup_modules_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [setup_modules_order_by!]

    # filter the rows returned
    where: setup_modules_bool_exp
  ): setup_modules_aggregate!

  # fetch data from the table: "setup_modules" using primary key columns
  setup_modules_by_pk(id: Int!): setup_modules

  # fetch data from the table: "tactic_goal_types"
  tactic_goal_types(
    # distinct select on columns
    distinct_on: [tactic_goal_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_goal_types_order_by!]

    # filter the rows returned
    where: tactic_goal_types_bool_exp
  ): [tactic_goal_types!]!

  # fetch aggregated fields from the table: "tactic_goal_types"
  tactic_goal_types_aggregate(
    # distinct select on columns
    distinct_on: [tactic_goal_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_goal_types_order_by!]

    # filter the rows returned
    where: tactic_goal_types_bool_exp
  ): tactic_goal_types_aggregate!

  # fetch data from the table: "tactic_goal_types" using primary key columns
  tactic_goal_types_by_pk(value: String!): tactic_goal_types

  # fetch data from the table: "tactic_types"
  tactic_types(
    # distinct select on columns
    distinct_on: [tactic_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_types_order_by!]

    # filter the rows returned
    where: tactic_types_bool_exp
  ): [tactic_types!]!

  # fetch aggregated fields from the table: "tactic_types"
  tactic_types_aggregate(
    # distinct select on columns
    distinct_on: [tactic_types_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactic_types_order_by!]

    # filter the rows returned
    where: tactic_types_bool_exp
  ): tactic_types_aggregate!

  # fetch data from the table: "tactic_types" using primary key columns
  tactic_types_by_pk(value: String!): tactic_types

  # fetch data from the table: "tactics"
  tactics(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): [tactics!]!

  # fetch aggregated fields from the table: "tactics"
  tactics_aggregate(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): tactics_aggregate!

  # fetch data from the table: "tactics" using primary key columns
  tactics_by_pk(id: Int!): tactics

  # fetch data from the table: "traveler_segments"
  traveler_segments(
    # distinct select on columns
    distinct_on: [traveler_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [traveler_segments_order_by!]

    # filter the rows returned
    where: traveler_segments_bool_exp
  ): [traveler_segments!]!

  # fetch aggregated fields from the table: "traveler_segments"
  traveler_segments_aggregate(
    # distinct select on columns
    distinct_on: [traveler_segments_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [traveler_segments_order_by!]

    # filter the rows returned
    where: traveler_segments_bool_exp
  ): traveler_segments_aggregate!

  # fetch data from the table: "traveler_segments" using primary key columns
  traveler_segments_by_pk(id: Int!): traveler_segments
}

# columns and relationships of "tactic_goal_types"
type tactic_goal_types {
  description: String

  # An array relationship
  tactics(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): [tactics!]!

  # An aggregated array relationship
  tactics_aggregate(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): tactics_aggregate!
  value: String!
}

# aggregated selection of "tactic_goal_types"
type tactic_goal_types_aggregate {
  aggregate: tactic_goal_types_aggregate_fields
  nodes: [tactic_goal_types!]!
}

# aggregate fields of "tactic_goal_types"
type tactic_goal_types_aggregate_fields {
  count(columns: [tactic_goal_types_select_column!], distinct: Boolean): Int
  max: tactic_goal_types_max_fields
  min: tactic_goal_types_min_fields
}

# order by aggregate values of table "tactic_goal_types"
input tactic_goal_types_aggregate_order_by {
  count: order_by
  max: tactic_goal_types_max_order_by
  min: tactic_goal_types_min_order_by
}

# input type for inserting array relation for remote table "tactic_goal_types"
input tactic_goal_types_arr_rel_insert_input {
  data: [tactic_goal_types_insert_input!]!
  on_conflict: tactic_goal_types_on_conflict
}

# Boolean expression to filter rows from the table "tactic_goal_types". All fields are combined with a logical 'AND'.
input tactic_goal_types_bool_exp {
  _and: [tactic_goal_types_bool_exp]
  _not: tactic_goal_types_bool_exp
  _or: [tactic_goal_types_bool_exp]
  description: String_comparison_exp
  tactics: tactics_bool_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "tactic_goal_types"
enum tactic_goal_types_constraint {
  # unique or primary key constraint
  tactic_goal_types_pkey
}

# input type for inserting data into table "tactic_goal_types"
input tactic_goal_types_insert_input {
  description: String
  tactics: tactics_arr_rel_insert_input
  value: String
}

# aggregate max on columns
type tactic_goal_types_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "tactic_goal_types"
input tactic_goal_types_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type tactic_goal_types_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "tactic_goal_types"
input tactic_goal_types_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "tactic_goal_types"
type tactic_goal_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [tactic_goal_types!]!
}

# input type for inserting object relation for remote table "tactic_goal_types"
input tactic_goal_types_obj_rel_insert_input {
  data: tactic_goal_types_insert_input!
  on_conflict: tactic_goal_types_on_conflict
}

# on conflict condition type for table "tactic_goal_types"
input tactic_goal_types_on_conflict {
  constraint: tactic_goal_types_constraint!
  update_columns: [tactic_goal_types_update_column!]!
  where: tactic_goal_types_bool_exp
}

# ordering options when selecting data from "tactic_goal_types"
input tactic_goal_types_order_by {
  description: order_by
  tactics_aggregate: tactics_aggregate_order_by
  value: order_by
}

# primary key columns input for table: "tactic_goal_types"
input tactic_goal_types_pk_columns_input {
  value: String!
}

# select columns of table "tactic_goal_types"
enum tactic_goal_types_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "tactic_goal_types"
input tactic_goal_types_set_input {
  description: String
  value: String
}

# update columns of table "tactic_goal_types"
enum tactic_goal_types_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "tactic_types"
type tactic_types {
  description: String

  # An array relationship
  tactics(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): [tactics!]!

  # An aggregated array relationship
  tactics_aggregate(
    # distinct select on columns
    distinct_on: [tactics_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [tactics_order_by!]

    # filter the rows returned
    where: tactics_bool_exp
  ): tactics_aggregate!
  value: String!
}

# aggregated selection of "tactic_types"
type tactic_types_aggregate {
  aggregate: tactic_types_aggregate_fields
  nodes: [tactic_types!]!
}

# aggregate fields of "tactic_types"
type tactic_types_aggregate_fields {
  count(columns: [tactic_types_select_column!], distinct: Boolean): Int
  max: tactic_types_max_fields
  min: tactic_types_min_fields
}

# order by aggregate values of table "tactic_types"
input tactic_types_aggregate_order_by {
  count: order_by
  max: tactic_types_max_order_by
  min: tactic_types_min_order_by
}

# input type for inserting array relation for remote table "tactic_types"
input tactic_types_arr_rel_insert_input {
  data: [tactic_types_insert_input!]!
  on_conflict: tactic_types_on_conflict
}

# Boolean expression to filter rows from the table "tactic_types". All fields are combined with a logical 'AND'.
input tactic_types_bool_exp {
  _and: [tactic_types_bool_exp]
  _not: tactic_types_bool_exp
  _or: [tactic_types_bool_exp]
  description: String_comparison_exp
  tactics: tactics_bool_exp
  value: String_comparison_exp
}

# unique or primary key constraints on table "tactic_types"
enum tactic_types_constraint {
  # unique or primary key constraint
  tactic_types_pkey
}

# input type for inserting data into table "tactic_types"
input tactic_types_insert_input {
  description: String
  tactics: tactics_arr_rel_insert_input
  value: String
}

# aggregate max on columns
type tactic_types_max_fields {
  description: String
  value: String
}

# order by max() on columns of table "tactic_types"
input tactic_types_max_order_by {
  description: order_by
  value: order_by
}

# aggregate min on columns
type tactic_types_min_fields {
  description: String
  value: String
}

# order by min() on columns of table "tactic_types"
input tactic_types_min_order_by {
  description: order_by
  value: order_by
}

# response of any mutation on the table "tactic_types"
type tactic_types_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [tactic_types!]!
}

# input type for inserting object relation for remote table "tactic_types"
input tactic_types_obj_rel_insert_input {
  data: tactic_types_insert_input!
  on_conflict: tactic_types_on_conflict
}

# on conflict condition type for table "tactic_types"
input tactic_types_on_conflict {
  constraint: tactic_types_constraint!
  update_columns: [tactic_types_update_column!]!
  where: tactic_types_bool_exp
}

# ordering options when selecting data from "tactic_types"
input tactic_types_order_by {
  description: order_by
  tactics_aggregate: tactics_aggregate_order_by
  value: order_by
}

# primary key columns input for table: "tactic_types"
input tactic_types_pk_columns_input {
  value: String!
}

# select columns of table "tactic_types"
enum tactic_types_select_column {
  # column name
  description

  # column name
  value
}

# input type for updating data in table "tactic_types"
input tactic_types_set_input {
  description: String
  value: String
}

# update columns of table "tactic_types"
enum tactic_types_update_column {
  # column name
  description

  # column name
  value
}

# columns and relationships of "tactics"
type tactics {
  # An object relationship
  campaign: campaigns
  campaign_id: Int

  # An array relationship
  channel_sets(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): [channel_sets!]!

  # An aggregated array relationship
  channel_sets_aggregate(
    # distinct select on columns
    distinct_on: [channel_sets_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [channel_sets_order_by!]

    # filter the rows returned
    where: channel_sets_bool_exp
  ): channel_sets_aggregate!
  created_at: timestamptz!
  goal_rate: String!
  goal_type: String
  id: Int!
  optimization_event: String

  # An object relationship
  tacticTypeByTacticType: tactic_types!

  # An object relationship
  tactic_goal_type: tactic_goal_types!
  tactic_type: String!
  updated_at: timestamptz!
}

# aggregated selection of "tactics"
type tactics_aggregate {
  aggregate: tactics_aggregate_fields
  nodes: [tactics!]!
}

# aggregate fields of "tactics"
type tactics_aggregate_fields {
  avg: tactics_avg_fields
  count(columns: [tactics_select_column!], distinct: Boolean): Int
  max: tactics_max_fields
  min: tactics_min_fields
  stddev: tactics_stddev_fields
  stddev_pop: tactics_stddev_pop_fields
  stddev_samp: tactics_stddev_samp_fields
  sum: tactics_sum_fields
  var_pop: tactics_var_pop_fields
  var_samp: tactics_var_samp_fields
  variance: tactics_variance_fields
}

# order by aggregate values of table "tactics"
input tactics_aggregate_order_by {
  avg: tactics_avg_order_by
  count: order_by
  max: tactics_max_order_by
  min: tactics_min_order_by
  stddev: tactics_stddev_order_by
  stddev_pop: tactics_stddev_pop_order_by
  stddev_samp: tactics_stddev_samp_order_by
  sum: tactics_sum_order_by
  var_pop: tactics_var_pop_order_by
  var_samp: tactics_var_samp_order_by
  variance: tactics_variance_order_by
}

# input type for inserting array relation for remote table "tactics"
input tactics_arr_rel_insert_input {
  data: [tactics_insert_input!]!
  on_conflict: tactics_on_conflict
}

# aggregate avg on columns
type tactics_avg_fields {
  campaign_id: Float
  id: Float
}

# order by avg() on columns of table "tactics"
input tactics_avg_order_by {
  campaign_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "tactics". All fields are combined with a logical 'AND'.
input tactics_bool_exp {
  _and: [tactics_bool_exp]
  _not: tactics_bool_exp
  _or: [tactics_bool_exp]
  campaign: campaigns_bool_exp
  campaign_id: Int_comparison_exp
  channel_sets: channel_sets_bool_exp
  created_at: timestamptz_comparison_exp
  goal_rate: String_comparison_exp
  goal_type: String_comparison_exp
  id: Int_comparison_exp
  optimization_event: String_comparison_exp
  tacticTypeByTacticType: tactic_types_bool_exp
  tactic_goal_type: tactic_goal_types_bool_exp
  tactic_type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "tactics"
enum tactics_constraint {
  # unique or primary key constraint
  tactics_pkey
}

# input type for incrementing integer column in table "tactics"
input tactics_inc_input {
  campaign_id: Int
  id: Int
}

# input type for inserting data into table "tactics"
input tactics_insert_input {
  campaign: campaigns_obj_rel_insert_input
  campaign_id: Int
  channel_sets: channel_sets_arr_rel_insert_input
  created_at: timestamptz
  goal_rate: String
  goal_type: String
  id: Int
  optimization_event: String
  tacticTypeByTacticType: tactic_types_obj_rel_insert_input
  tactic_goal_type: tactic_goal_types_obj_rel_insert_input
  tactic_type: String
  updated_at: timestamptz
}

# aggregate max on columns
type tactics_max_fields {
  campaign_id: Int
  created_at: timestamptz
  goal_rate: String
  goal_type: String
  id: Int
  optimization_event: String
  tactic_type: String
  updated_at: timestamptz
}

# order by max() on columns of table "tactics"
input tactics_max_order_by {
  campaign_id: order_by
  created_at: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  optimization_event: order_by
  tactic_type: order_by
  updated_at: order_by
}

# aggregate min on columns
type tactics_min_fields {
  campaign_id: Int
  created_at: timestamptz
  goal_rate: String
  goal_type: String
  id: Int
  optimization_event: String
  tactic_type: String
  updated_at: timestamptz
}

# order by min() on columns of table "tactics"
input tactics_min_order_by {
  campaign_id: order_by
  created_at: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  optimization_event: order_by
  tactic_type: order_by
  updated_at: order_by
}

# response of any mutation on the table "tactics"
type tactics_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [tactics!]!
}

# input type for inserting object relation for remote table "tactics"
input tactics_obj_rel_insert_input {
  data: tactics_insert_input!
  on_conflict: tactics_on_conflict
}

# on conflict condition type for table "tactics"
input tactics_on_conflict {
  constraint: tactics_constraint!
  update_columns: [tactics_update_column!]!
  where: tactics_bool_exp
}

# ordering options when selecting data from "tactics"
input tactics_order_by {
  campaign: campaigns_order_by
  campaign_id: order_by
  channel_sets_aggregate: channel_sets_aggregate_order_by
  created_at: order_by
  goal_rate: order_by
  goal_type: order_by
  id: order_by
  optimization_event: order_by
  tacticTypeByTacticType: tactic_types_order_by
  tactic_goal_type: tactic_goal_types_order_by
  tactic_type: order_by
  updated_at: order_by
}

# primary key columns input for table: "tactics"
input tactics_pk_columns_input {
  id: Int!
}

# select columns of table "tactics"
enum tactics_select_column {
  # column name
  campaign_id

  # column name
  created_at

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  optimization_event

  # column name
  tactic_type

  # column name
  updated_at
}

# input type for updating data in table "tactics"
input tactics_set_input {
  campaign_id: Int
  created_at: timestamptz
  goal_rate: String
  goal_type: String
  id: Int
  optimization_event: String
  tactic_type: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type tactics_stddev_fields {
  campaign_id: Float
  id: Float
}

# order by stddev() on columns of table "tactics"
input tactics_stddev_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type tactics_stddev_pop_fields {
  campaign_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "tactics"
input tactics_stddev_pop_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type tactics_stddev_samp_fields {
  campaign_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "tactics"
input tactics_stddev_samp_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate sum on columns
type tactics_sum_fields {
  campaign_id: Int
  id: Int
}

# order by sum() on columns of table "tactics"
input tactics_sum_order_by {
  campaign_id: order_by
  id: order_by
}

# update columns of table "tactics"
enum tactics_update_column {
  # column name
  campaign_id

  # column name
  created_at

  # column name
  goal_rate

  # column name
  goal_type

  # column name
  id

  # column name
  optimization_event

  # column name
  tactic_type

  # column name
  updated_at
}

# aggregate var_pop on columns
type tactics_var_pop_fields {
  campaign_id: Float
  id: Float
}

# order by var_pop() on columns of table "tactics"
input tactics_var_pop_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type tactics_var_samp_fields {
  campaign_id: Float
  id: Float
}

# order by var_samp() on columns of table "tactics"
input tactics_var_samp_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate variance on columns
type tactics_variance_fields {
  campaign_id: Float
  id: Float
}

# order by variance() on columns of table "tactics"
input tactics_variance_order_by {
  campaign_id: order_by
  id: order_by
}

scalar timestamptz

# expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

# columns and relationships of "traveler_segments"
type traveler_segments {
  # An object relationship
  channel_set: channel_sets
  channel_set_id: Int
  created_at: timestamptz!
  created_by: String
  id: Int!
  name: String
  type: String
  updated_at: timestamptz!
}

# aggregated selection of "traveler_segments"
type traveler_segments_aggregate {
  aggregate: traveler_segments_aggregate_fields
  nodes: [traveler_segments!]!
}

# aggregate fields of "traveler_segments"
type traveler_segments_aggregate_fields {
  avg: traveler_segments_avg_fields
  count(columns: [traveler_segments_select_column!], distinct: Boolean): Int
  max: traveler_segments_max_fields
  min: traveler_segments_min_fields
  stddev: traveler_segments_stddev_fields
  stddev_pop: traveler_segments_stddev_pop_fields
  stddev_samp: traveler_segments_stddev_samp_fields
  sum: traveler_segments_sum_fields
  var_pop: traveler_segments_var_pop_fields
  var_samp: traveler_segments_var_samp_fields
  variance: traveler_segments_variance_fields
}

# order by aggregate values of table "traveler_segments"
input traveler_segments_aggregate_order_by {
  avg: traveler_segments_avg_order_by
  count: order_by
  max: traveler_segments_max_order_by
  min: traveler_segments_min_order_by
  stddev: traveler_segments_stddev_order_by
  stddev_pop: traveler_segments_stddev_pop_order_by
  stddev_samp: traveler_segments_stddev_samp_order_by
  sum: traveler_segments_sum_order_by
  var_pop: traveler_segments_var_pop_order_by
  var_samp: traveler_segments_var_samp_order_by
  variance: traveler_segments_variance_order_by
}

# input type for inserting array relation for remote table "traveler_segments"
input traveler_segments_arr_rel_insert_input {
  data: [traveler_segments_insert_input!]!
  on_conflict: traveler_segments_on_conflict
}

# aggregate avg on columns
type traveler_segments_avg_fields {
  channel_set_id: Float
  id: Float
}

# order by avg() on columns of table "traveler_segments"
input traveler_segments_avg_order_by {
  channel_set_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "traveler_segments". All fields are combined with a logical 'AND'.
input traveler_segments_bool_exp {
  _and: [traveler_segments_bool_exp]
  _not: traveler_segments_bool_exp
  _or: [traveler_segments_bool_exp]
  channel_set: channel_sets_bool_exp
  channel_set_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  created_by: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

# unique or primary key constraints on table "traveler_segments"
enum traveler_segments_constraint {
  # unique or primary key constraint
  traveler_segments_pkey
}

# input type for incrementing integer column in table "traveler_segments"
input traveler_segments_inc_input {
  channel_set_id: Int
  id: Int
}

# input type for inserting data into table "traveler_segments"
input traveler_segments_insert_input {
  channel_set: channel_sets_obj_rel_insert_input
  channel_set_id: Int
  created_at: timestamptz
  created_by: String
  id: Int
  name: String
  type: String
  updated_at: timestamptz
}

# aggregate max on columns
type traveler_segments_max_fields {
  channel_set_id: Int
  created_at: timestamptz
  created_by: String
  id: Int
  name: String
  type: String
  updated_at: timestamptz
}

# order by max() on columns of table "traveler_segments"
input traveler_segments_max_order_by {
  channel_set_id: order_by
  created_at: order_by
  created_by: order_by
  id: order_by
  name: order_by
  type: order_by
  updated_at: order_by
}

# aggregate min on columns
type traveler_segments_min_fields {
  channel_set_id: Int
  created_at: timestamptz
  created_by: String
  id: Int
  name: String
  type: String
  updated_at: timestamptz
}

# order by min() on columns of table "traveler_segments"
input traveler_segments_min_order_by {
  channel_set_id: order_by
  created_at: order_by
  created_by: order_by
  id: order_by
  name: order_by
  type: order_by
  updated_at: order_by
}

# response of any mutation on the table "traveler_segments"
type traveler_segments_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [traveler_segments!]!
}

# input type for inserting object relation for remote table "traveler_segments"
input traveler_segments_obj_rel_insert_input {
  data: traveler_segments_insert_input!
  on_conflict: traveler_segments_on_conflict
}

# on conflict condition type for table "traveler_segments"
input traveler_segments_on_conflict {
  constraint: traveler_segments_constraint!
  update_columns: [traveler_segments_update_column!]!
  where: traveler_segments_bool_exp
}

# ordering options when selecting data from "traveler_segments"
input traveler_segments_order_by {
  channel_set: channel_sets_order_by
  channel_set_id: order_by
  created_at: order_by
  created_by: order_by
  id: order_by
  name: order_by
  type: order_by
  updated_at: order_by
}

# primary key columns input for table: "traveler_segments"
input traveler_segments_pk_columns_input {
  id: Int!
}

# select columns of table "traveler_segments"
enum traveler_segments_select_column {
  # column name
  channel_set_id

  # column name
  created_at

  # column name
  created_by

  # column name
  id

  # column name
  name

  # column name
  type

  # column name
  updated_at
}

# input type for updating data in table "traveler_segments"
input traveler_segments_set_input {
  channel_set_id: Int
  created_at: timestamptz
  created_by: String
  id: Int
  name: String
  type: String
  updated_at: timestamptz
}

# aggregate stddev on columns
type traveler_segments_stddev_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev() on columns of table "traveler_segments"
input traveler_segments_stddev_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type traveler_segments_stddev_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "traveler_segments"
input traveler_segments_stddev_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type traveler_segments_stddev_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "traveler_segments"
input traveler_segments_stddev_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate sum on columns
type traveler_segments_sum_fields {
  channel_set_id: Int
  id: Int
}

# order by sum() on columns of table "traveler_segments"
input traveler_segments_sum_order_by {
  channel_set_id: order_by
  id: order_by
}

# update columns of table "traveler_segments"
enum traveler_segments_update_column {
  # column name
  channel_set_id

  # column name
  created_at

  # column name
  created_by

  # column name
  id

  # column name
  name

  # column name
  type

  # column name
  updated_at
}

# aggregate var_pop on columns
type traveler_segments_var_pop_fields {
  channel_set_id: Float
  id: Float
}

# order by var_pop() on columns of table "traveler_segments"
input traveler_segments_var_pop_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type traveler_segments_var_samp_fields {
  channel_set_id: Float
  id: Float
}

# order by var_samp() on columns of table "traveler_segments"
input traveler_segments_var_samp_order_by {
  channel_set_id: order_by
  id: order_by
}

# aggregate variance on columns
type traveler_segments_variance_fields {
  channel_set_id: Float
  id: Float
}

# order by variance() on columns of table "traveler_segments"
input traveler_segments_variance_order_by {
  channel_set_id: order_by
  id: order_by
}

